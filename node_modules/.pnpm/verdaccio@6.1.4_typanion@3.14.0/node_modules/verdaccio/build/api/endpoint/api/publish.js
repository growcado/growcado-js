"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addVersion = addVersion;
exports.default = publish;
exports.publishPackage = publishPackage;
exports.removeTarball = removeTarball;
exports.unPublishPackage = unPublishPackage;
exports.uploadPackageTarball = uploadPackageTarball;
var _debug = _interopRequireDefault(require("debug"));
var _lodash = _interopRequireDefault(require("lodash"));
var _mime = _interopRequireDefault(require("mime"));
var _path = _interopRequireDefault(require("path"));
var _core = require("@verdaccio/core");
var _middleware = require("@verdaccio/middleware");
var _constants = require("../../../lib/constants");
var _logger = require("../../../lib/logger");
var _notify = require("../../../lib/notify");
var _storageUtils = require("../../../lib/storage-utils");
var _utils = require("../../../lib/utils");
var _star = _interopRequireDefault(require("./star"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const debug = (0, _debug.default)('verdaccio:publish');
function publish(router, auth, storage, config) {
  const can = (0, _middleware.allow)(auth, {
    beforeAll: (params, message) => _logger.logger.trace(params, message),
    afterAll: (params, message) => _logger.logger.trace(params, message)
  });

  /**
   * Publish a package / update package / un/start a package
   *
   * There are multiples scenarios here to be considered:
   *
   * 1. Publish scenario
   *
   * Publish a package consist of at least 1 step (PUT) with a metadata payload.
   * When a package is published, an _attachment property is present that contains the data
   * of the tarball.
   *
   * Example flow of publish.
   *
   *  npm http fetch PUT 201 http://localhost:4873/@scope%2ftest1 9627ms
      npm info lifecycle @scope/test1@1.0.1~publish: @scope/test1@1.0.1
      npm info lifecycle @scope/test1@1.0.1~postpublish: @scope/test1@1.0.1
      + @scope/test1@1.0.1
      npm verb exit [ 0, true ]
   *
   *
   * 2. Unpublish scenario
   *
   * Unpublish consist in 3 steps.
   *  1. Try to fetch  metadata -> if it fails, return 404
   *  2. Compute metadata locally (client side) and send a mutate payload excluding the version to be unpublished
   *    eg: if metadata reflects 1.0.1, 1.0.2 and 1.0.3, the computed metadata won't include 1.0.3.
   *  3. Once the second step has been successfully finished, delete the tarball.
   *
   *  All these steps are consecutive and required, there is no transacions here, if step 3 fails, metadata might
   *  get corrupted.
   *
   *  Note the unpublish call will suffix in the url a /-rev/14-5d500cfce92f90fd revision number, this not
   *  used internally.
   *
   *
   * Example flow of unpublish.
   *
   * npm http fetch GET 200 http://localhost:4873/@scope%2ftest1?write=true 1680ms
     npm http fetch PUT 201 http://localhost:4873/@scope%2ftest1/-rev/14-5d500cfce92f90fd 956606ms attempt #2
     npm http fetch GET 200 http://localhost:4873/@scope%2ftest1?write=true 1601ms
     npm http fetch DELETE 201 http://localhost:4873/@scope%2ftest1/-/test1-1.0.3.tgz/-rev/16-e11c8db282b2d992 19ms
   *
   * 3. Star a package
   *
   * Permissions: start a package depends of the publish and unpublish permissions, there is no specific flag for star or un start.
   * The URL for star is similar to the unpublish (change package format)
   *
   * npm has no enpoint for star a package, rather mutate the metadata and acts as, the difference is the
   * users property which is part of the payload and the body only includes
   *
   * {
    "_id": pkgName,
   	"_rev": "3-b0cdaefc9bdb77c8",
    "users": {
      [username]: boolean value (true, false)
    }
  }
   *
   */
  router.put('/:package/:_rev?/:revision?', can('publish'), (0, _middleware.media)(_mime.default.getType('json')), _middleware.expectJson, publishPackage(storage, config, auth));

  /**
   * Un-publishing an entire package.
   *
   * This scenario happens when the first call detect there is only one version remaining
   * in the metadata, then the client decides to DELETE the resource
   * npm http fetch GET 304 http://localhost:4873/@scope%2ftest1?write=true 1076ms (from cache)
     npm http fetch DELETE 201 http://localhost:4873/@scope%2ftest1/-rev/18-d8ebe3020bd4ac9c 22ms
   */
  router.delete('/:package/-rev/*', can('unpublish'), unPublishPackage(storage));

  // removing a tarball
  router.delete('/:package/-/:filename/-rev/:revision', can('unpublish'), can('publish'), removeTarball(storage));

  // uploading package tarball
  router.put('/:package/-/:filename/*', can('publish'), (0, _middleware.media)(_constants.HEADERS.OCTET_STREAM), uploadPackageTarball(storage));

  // only used for development
  if (config._debug) {
    // adding a version
    router.put('/:package/:version/-tag/:tag', can('publish'), (0, _middleware.media)(_mime.default.getType('json')), _middleware.expectJson, addVersion(storage));
  }
}

/**
 * Publish a package
 */
function publishPackage(storage, config, auth) {
  const starApi = (0, _star.default)(storage);
  return function (req, res, next) {
    const packageName = req.params.package;
    debug('publishing or updating a new version for %o', packageName);
    /**
     * Write tarball of stream data from package clients.
     */
    const createTarball = function (filename, data, cb) {
      const stream = storage.addTarball(packageName, filename);
      stream.on('error', function (err) {
        cb(err);
      });
      stream.on('success', function () {
        cb();
      });
      // this is dumb and memory-consuming, but what choices do we have?
      // flow: we need first refactor this file before decides which type use here
      stream.end(Buffer.from(data.data, 'base64'));
      stream.done();
    };

    /**
     * Add new package version in storage
     */
    const createVersion = function (version, metadata, cb) {
      storage.addVersion(packageName, version, metadata, null, cb);
    };

    /**
     * Add new tags in storage
     */
    const addTags = function (tags, cb) {
      storage.mergeTags(packageName, tags, cb);
    };
    const afterChange = function (error, okMessage, metadata) {
      const metadataCopy = _objectSpread({}, metadata);
      const {
        _attachments,
        versions
      } = metadataCopy;

      // `npm star` wouldn't have attachments
      // and `npm deprecate` would have attachments as a empty object, i.e {}
      if (_lodash.default.isNil(_attachments) || JSON.stringify(_attachments) === '{}') {
        if (error) {
          return next(error);
        }
        res.status(_constants.HTTP_STATUS.CREATED);
        return next({
          ok: okMessage,
          success: true
        });
      }

      // npm-registry-client 0.3+ embeds tarball into the json upload
      // https://github.com/isaacs/npm-registry-client/commit/e9fbeb8b67f249394f735c74ef11fe4720d46ca0
      // issue https://github.com/rlidwka/sinopia/issues/31, dealing with it here:
      const isInvalidBodyFormat = (0, _utils.isObject)(_attachments) === false || (0, _utils.hasDiffOneKey)(_attachments) || (0, _utils.isObject)(versions) === false || (0, _utils.hasDiffOneKey)(versions);
      if (isInvalidBodyFormat) {
        // npm is doing something strange again
        // if this happens in normal circumstances, report it as a bug
        _logger.logger.info({
          packageName
        }, `wrong package format on publish a package @{packageName}`);
        return next(_utils.ErrorCode.getBadRequest(_constants.API_ERROR.UNSUPORTED_REGISTRY_CALL));
      }
      if (error && error.status !== _constants.HTTP_STATUS.CONFLICT) {
        return next(error);
      }

      // at this point document is either created or existed before
      const [firstAttachmentKey] = Object.keys(_attachments);
      createTarball(_path.default.basename(firstAttachmentKey), _attachments[firstAttachmentKey], function (error) {
        if (error) {
          return next(error);
        }
        const versionToPublish = Object.keys(versions)[0];
        const versionMetadataToPublish = versions[versionToPublish];
        versionMetadataToPublish.readme = _lodash.default.isNil(versionMetadataToPublish.readme) === false ? String(versionMetadataToPublish.readme) : '';
        createVersion(versionToPublish, versionMetadataToPublish, function (error) {
          if (error) {
            return next(error);
          }
          addTags(metadataCopy[_constants.DIST_TAGS], async function (error) {
            if (error) {
              return next(error);
            }
            try {
              await (0, _notify.notify)(metadataCopy, config, req.remote_user, `${metadataCopy.name}@${versionToPublish}`);
            } catch (error) {
              _logger.logger.error({
                error
              }, 'notify batch service has failed: @{error}');
            }
            res.status(_constants.HTTP_STATUS.CREATED);
            return next({
              ok: okMessage,
              success: true
            });
          });
        });
      });
    };
    if ((0, _storageUtils.isPublishablePackage)(req.body) === false && (0, _utils.isObject)(req.body.users)) {
      return starApi(req, res, next);
    }
    try {
      const metadata = _core.validationUtils.normalizeMetadata(req.body, packageName);
      // check _attachments to distinguish publish and deprecate
      if (req.params._rev || (0, _utils.isRelatedToDeprecation)(req.body) && _lodash.default.isEmpty(req.body._attachments)) {
        debug('updating a new version for %o', packageName);
        // we check unpublish permissions, an update is basically remove versions
        const remote = req.remote_user;
        auth.allow_unpublish({
          packageName
        }, remote, error => {
          if (error) {
            _logger.logger.error({
              packageName
            }, `not allowed to unpublish a version for @{packageName}`);
            return next(error);
          }
          storage.changePackage(packageName, metadata, req.params.revision, function (error) {
            afterChange(error, _constants.API_MESSAGE.PKG_CHANGED, metadata);
          });
        });
      } else {
        debug('adding a new version for %o', packageName);
        storage.addPackage(packageName, metadata, function (error) {
          afterChange(error, _constants.API_MESSAGE.PKG_CREATED, metadata);
        });
      }
    } catch (error) {
      _logger.logger.error({
        packageName
      }, 'error on publish, bad package data for @{packageName}');
      return next(_utils.ErrorCode.getBadData(_constants.API_ERROR.BAD_PACKAGE_DATA));
    }
  };
}

/**
 * un-publish a package
 */
function unPublishPackage(storage) {
  return function (req, res, next) {
    const packageName = req.params.package;
    debug('unpublishing %o', packageName);
    storage.removePackage(packageName, function (err) {
      if (err) {
        return next(err);
      }
      res.status(_constants.HTTP_STATUS.CREATED);
      return next({
        ok: _constants.API_MESSAGE.PKG_REMOVED
      });
    });
  };
}

/**
 * Delete tarball
 */
function removeTarball(storage) {
  return function (req, res, next) {
    const packageName = req.params.package;
    const {
      filename,
      revision
    } = req.params;
    debug('removing a tarball for %o-%o-%o', packageName, filename, revision);
    storage.removeTarball(packageName, filename, revision, function (err) {
      if (err) {
        return next(err);
      }
      res.status(_constants.HTTP_STATUS.CREATED);
      debug('success remove tarball for %o-%o-%o', packageName, filename, revision);
      return next({
        ok: _constants.API_MESSAGE.TARBALL_REMOVED
      });
    });
  };
}
/**
 * Adds a new version
 */
function addVersion(storage) {
  return function (req, res, next) {
    const {
      version,
      tag
    } = req.params;
    const packageName = req.params.package;
    storage.addVersion(packageName, version, req.body, tag, function (error) {
      if (error) {
        return next(error);
      }
      res.status(_constants.HTTP_STATUS.CREATED);
      return next({
        ok: _constants.API_MESSAGE.PKG_PUBLISHED
      });
    });
  };
}

/**
 * uploadPackageTarball
 */
function uploadPackageTarball(storage) {
  return function (req, res, next) {
    const packageName = req.params.package;
    const stream = storage.addTarball(packageName, req.params.filename);
    req.pipe(stream);

    // checking if end event came before closing
    let complete = false;
    req.on('end', function () {
      complete = true;
      stream.done();
    });
    req.on('close', function () {
      if (!complete) {
        stream.abort();
      }
    });
    stream.on('error', function (err) {
      return res.locals.report_error(err);
    });
    stream.on('success', function () {
      res.status(_constants.HTTP_STATUS.CREATED);
      return next({
        ok: _constants.API_MESSAGE.TARBALL_UPLOADED
      });
    });
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZGVidWciLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9sb2Rhc2giLCJfbWltZSIsIl9wYXRoIiwiX2NvcmUiLCJfbWlkZGxld2FyZSIsIl9jb25zdGFudHMiLCJfbG9nZ2VyIiwiX25vdGlmeSIsIl9zdG9yYWdlVXRpbHMiLCJfdXRpbHMiLCJfc3RhciIsImUiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsIm93bktleXMiLCJyIiwidCIsIk9iamVjdCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJvIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIl90b1Byb3BlcnR5S2V5IiwidmFsdWUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImkiLCJfdG9QcmltaXRpdmUiLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsImNhbGwiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJkZWJ1ZyIsImJ1aWxkRGVidWciLCJwdWJsaXNoIiwicm91dGVyIiwiYXV0aCIsInN0b3JhZ2UiLCJjb25maWciLCJjYW4iLCJhbGxvdyIsImJlZm9yZUFsbCIsInBhcmFtcyIsIm1lc3NhZ2UiLCJsb2dnZXIiLCJ0cmFjZSIsImFmdGVyQWxsIiwicHV0IiwibWVkaWEiLCJtaW1lIiwiZ2V0VHlwZSIsImV4cGVjdEpzb24iLCJwdWJsaXNoUGFja2FnZSIsImRlbGV0ZSIsInVuUHVibGlzaFBhY2thZ2UiLCJyZW1vdmVUYXJiYWxsIiwiSEVBREVSUyIsIk9DVEVUX1NUUkVBTSIsInVwbG9hZFBhY2thZ2VUYXJiYWxsIiwiYWRkVmVyc2lvbiIsInN0YXJBcGkiLCJzdGFyIiwicmVxIiwicmVzIiwibmV4dCIsInBhY2thZ2VOYW1lIiwicGFja2FnZSIsImNyZWF0ZVRhcmJhbGwiLCJmaWxlbmFtZSIsImRhdGEiLCJjYiIsInN0cmVhbSIsImFkZFRhcmJhbGwiLCJvbiIsImVyciIsImVuZCIsIkJ1ZmZlciIsImZyb20iLCJkb25lIiwiY3JlYXRlVmVyc2lvbiIsInZlcnNpb24iLCJtZXRhZGF0YSIsImFkZFRhZ3MiLCJ0YWdzIiwibWVyZ2VUYWdzIiwiYWZ0ZXJDaGFuZ2UiLCJlcnJvciIsIm9rTWVzc2FnZSIsIm1ldGFkYXRhQ29weSIsIl9hdHRhY2htZW50cyIsInZlcnNpb25zIiwiXyIsImlzTmlsIiwiSlNPTiIsInN0cmluZ2lmeSIsInN0YXR1cyIsIkhUVFBfU1RBVFVTIiwiQ1JFQVRFRCIsIm9rIiwic3VjY2VzcyIsImlzSW52YWxpZEJvZHlGb3JtYXQiLCJpc09iamVjdCIsImhhc0RpZmZPbmVLZXkiLCJpbmZvIiwiRXJyb3JDb2RlIiwiZ2V0QmFkUmVxdWVzdCIsIkFQSV9FUlJPUiIsIlVOU1VQT1JURURfUkVHSVNUUllfQ0FMTCIsIkNPTkZMSUNUIiwiZmlyc3RBdHRhY2htZW50S2V5IiwiUGF0aCIsImJhc2VuYW1lIiwidmVyc2lvblRvUHVibGlzaCIsInZlcnNpb25NZXRhZGF0YVRvUHVibGlzaCIsInJlYWRtZSIsIkRJU1RfVEFHUyIsIm5vdGlmeSIsInJlbW90ZV91c2VyIiwibmFtZSIsImlzUHVibGlzaGFibGVQYWNrYWdlIiwiYm9keSIsInVzZXJzIiwidmFsaWRhdGlvblV0aWxzIiwibm9ybWFsaXplTWV0YWRhdGEiLCJfcmV2IiwiaXNSZWxhdGVkVG9EZXByZWNhdGlvbiIsImlzRW1wdHkiLCJyZW1vdGUiLCJhbGxvd191bnB1Ymxpc2giLCJjaGFuZ2VQYWNrYWdlIiwicmV2aXNpb24iLCJBUElfTUVTU0FHRSIsIlBLR19DSEFOR0VEIiwiYWRkUGFja2FnZSIsIlBLR19DUkVBVEVEIiwiZ2V0QmFkRGF0YSIsIkJBRF9QQUNLQUdFX0RBVEEiLCJyZW1vdmVQYWNrYWdlIiwiUEtHX1JFTU9WRUQiLCJUQVJCQUxMX1JFTU9WRUQiLCJ0YWciLCJQS0dfUFVCTElTSEVEIiwicGlwZSIsImNvbXBsZXRlIiwiYWJvcnQiLCJsb2NhbHMiLCJyZXBvcnRfZXJyb3IiLCJUQVJCQUxMX1VQTE9BREVEIl0sInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2FwaS9lbmRwb2ludC9hcGkvcHVibGlzaC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYnVpbGREZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgeyBSb3V0ZXIgfSBmcm9tICdleHByZXNzJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgbWltZSBmcm9tICdtaW1lJztcbmltcG9ydCBQYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgeyB2YWxpZGF0aW9uVXRpbHMgfSBmcm9tICdAdmVyZGFjY2lvL2NvcmUnO1xuaW1wb3J0IHsgYWxsb3csIGV4cGVjdEpzb24sIG1lZGlhIH0gZnJvbSAnQHZlcmRhY2Npby9taWRkbGV3YXJlJztcbmltcG9ydCB7IENhbGxiYWNrLCBDb25maWcsIE1lcmdlVGFncywgUGFja2FnZSwgVmVyc2lvbiB9IGZyb20gJ0B2ZXJkYWNjaW8vdHlwZXMnO1xuXG5pbXBvcnQgQXV0aCBmcm9tICcuLi8uLi8uLi9saWIvYXV0aCc7XG5pbXBvcnQgeyBBUElfRVJST1IsIEFQSV9NRVNTQUdFLCBESVNUX1RBR1MsIEhFQURFUlMsIEhUVFBfU1RBVFVTIH0gZnJvbSAnLi4vLi4vLi4vbGliL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi8uLi8uLi9saWIvbG9nZ2VyJztcbmltcG9ydCB7IG5vdGlmeSB9IGZyb20gJy4uLy4uLy4uL2xpYi9ub3RpZnknO1xuaW1wb3J0IFN0b3JhZ2UgZnJvbSAnLi4vLi4vLi4vbGliL3N0b3JhZ2UnO1xuaW1wb3J0IHsgaXNQdWJsaXNoYWJsZVBhY2thZ2UgfSBmcm9tICcuLi8uLi8uLi9saWIvc3RvcmFnZS11dGlscyc7XG5pbXBvcnQgeyBFcnJvckNvZGUsIGhhc0RpZmZPbmVLZXksIGlzT2JqZWN0LCBpc1JlbGF0ZWRUb0RlcHJlY2F0aW9uIH0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzJztcbmltcG9ydCB7ICROZXh0RnVuY3Rpb25WZXIsICRSZXF1ZXN0RXh0ZW5kLCAkUmVzcG9uc2VFeHRlbmQgfSBmcm9tICcuLi8uLi8uLi90eXBlcyc7XG5pbXBvcnQgc3RhciBmcm9tICcuL3N0YXInO1xuXG5jb25zdCBkZWJ1ZyA9IGJ1aWxkRGVidWcoJ3ZlcmRhY2NpbzpwdWJsaXNoJyk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHB1Ymxpc2goXG4gIHJvdXRlcjogUm91dGVyLFxuICBhdXRoOiBBdXRoLFxuICBzdG9yYWdlOiBTdG9yYWdlLFxuICBjb25maWc6IENvbmZpZ1xuKTogdm9pZCB7XG4gIGNvbnN0IGNhbiA9IGFsbG93KGF1dGgsIHtcbiAgICBiZWZvcmVBbGw6IChwYXJhbXMsIG1lc3NhZ2UpID0+IGxvZ2dlci50cmFjZShwYXJhbXMsIG1lc3NhZ2UpLFxuICAgIGFmdGVyQWxsOiAocGFyYW1zLCBtZXNzYWdlKSA9PiBsb2dnZXIudHJhY2UocGFyYW1zLCBtZXNzYWdlKSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFB1Ymxpc2ggYSBwYWNrYWdlIC8gdXBkYXRlIHBhY2thZ2UgLyB1bi9zdGFydCBhIHBhY2thZ2VcbiAgICpcbiAgICogVGhlcmUgYXJlIG11bHRpcGxlcyBzY2VuYXJpb3MgaGVyZSB0byBiZSBjb25zaWRlcmVkOlxuICAgKlxuICAgKiAxLiBQdWJsaXNoIHNjZW5hcmlvXG4gICAqXG4gICAqIFB1Ymxpc2ggYSBwYWNrYWdlIGNvbnNpc3Qgb2YgYXQgbGVhc3QgMSBzdGVwIChQVVQpIHdpdGggYSBtZXRhZGF0YSBwYXlsb2FkLlxuICAgKiBXaGVuIGEgcGFja2FnZSBpcyBwdWJsaXNoZWQsIGFuIF9hdHRhY2htZW50IHByb3BlcnR5IGlzIHByZXNlbnQgdGhhdCBjb250YWlucyB0aGUgZGF0YVxuICAgKiBvZiB0aGUgdGFyYmFsbC5cbiAgICpcbiAgICogRXhhbXBsZSBmbG93IG9mIHB1Ymxpc2guXG4gICAqXG4gICAqICBucG0gaHR0cCBmZXRjaCBQVVQgMjAxIGh0dHA6Ly9sb2NhbGhvc3Q6NDg3My9Ac2NvcGUlMmZ0ZXN0MSA5NjI3bXNcbiAgICAgIG5wbSBpbmZvIGxpZmVjeWNsZSBAc2NvcGUvdGVzdDFAMS4wLjF+cHVibGlzaDogQHNjb3BlL3Rlc3QxQDEuMC4xXG4gICAgICBucG0gaW5mbyBsaWZlY3ljbGUgQHNjb3BlL3Rlc3QxQDEuMC4xfnBvc3RwdWJsaXNoOiBAc2NvcGUvdGVzdDFAMS4wLjFcbiAgICAgICsgQHNjb3BlL3Rlc3QxQDEuMC4xXG4gICAgICBucG0gdmVyYiBleGl0IFsgMCwgdHJ1ZSBdXG4gICAqXG4gICAqXG4gICAqIDIuIFVucHVibGlzaCBzY2VuYXJpb1xuICAgKlxuICAgKiBVbnB1Ymxpc2ggY29uc2lzdCBpbiAzIHN0ZXBzLlxuICAgKiAgMS4gVHJ5IHRvIGZldGNoICBtZXRhZGF0YSAtPiBpZiBpdCBmYWlscywgcmV0dXJuIDQwNFxuICAgKiAgMi4gQ29tcHV0ZSBtZXRhZGF0YSBsb2NhbGx5IChjbGllbnQgc2lkZSkgYW5kIHNlbmQgYSBtdXRhdGUgcGF5bG9hZCBleGNsdWRpbmcgdGhlIHZlcnNpb24gdG8gYmUgdW5wdWJsaXNoZWRcbiAgICogICAgZWc6IGlmIG1ldGFkYXRhIHJlZmxlY3RzIDEuMC4xLCAxLjAuMiBhbmQgMS4wLjMsIHRoZSBjb21wdXRlZCBtZXRhZGF0YSB3b24ndCBpbmNsdWRlIDEuMC4zLlxuICAgKiAgMy4gT25jZSB0aGUgc2Vjb25kIHN0ZXAgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGZpbmlzaGVkLCBkZWxldGUgdGhlIHRhcmJhbGwuXG4gICAqXG4gICAqICBBbGwgdGhlc2Ugc3RlcHMgYXJlIGNvbnNlY3V0aXZlIGFuZCByZXF1aXJlZCwgdGhlcmUgaXMgbm8gdHJhbnNhY2lvbnMgaGVyZSwgaWYgc3RlcCAzIGZhaWxzLCBtZXRhZGF0YSBtaWdodFxuICAgKiAgZ2V0IGNvcnJ1cHRlZC5cbiAgICpcbiAgICogIE5vdGUgdGhlIHVucHVibGlzaCBjYWxsIHdpbGwgc3VmZml4IGluIHRoZSB1cmwgYSAvLXJldi8xNC01ZDUwMGNmY2U5MmY5MGZkIHJldmlzaW9uIG51bWJlciwgdGhpcyBub3RcbiAgICogIHVzZWQgaW50ZXJuYWxseS5cbiAgICpcbiAgICpcbiAgICogRXhhbXBsZSBmbG93IG9mIHVucHVibGlzaC5cbiAgICpcbiAgICogbnBtIGh0dHAgZmV0Y2ggR0VUIDIwMCBodHRwOi8vbG9jYWxob3N0OjQ4NzMvQHNjb3BlJTJmdGVzdDE/d3JpdGU9dHJ1ZSAxNjgwbXNcbiAgICAgbnBtIGh0dHAgZmV0Y2ggUFVUIDIwMSBodHRwOi8vbG9jYWxob3N0OjQ4NzMvQHNjb3BlJTJmdGVzdDEvLXJldi8xNC01ZDUwMGNmY2U5MmY5MGZkIDk1NjYwNm1zIGF0dGVtcHQgIzJcbiAgICAgbnBtIGh0dHAgZmV0Y2ggR0VUIDIwMCBodHRwOi8vbG9jYWxob3N0OjQ4NzMvQHNjb3BlJTJmdGVzdDE/d3JpdGU9dHJ1ZSAxNjAxbXNcbiAgICAgbnBtIGh0dHAgZmV0Y2ggREVMRVRFIDIwMSBodHRwOi8vbG9jYWxob3N0OjQ4NzMvQHNjb3BlJTJmdGVzdDEvLS90ZXN0MS0xLjAuMy50Z3ovLXJldi8xNi1lMTFjOGRiMjgyYjJkOTkyIDE5bXNcbiAgICpcbiAgICogMy4gU3RhciBhIHBhY2thZ2VcbiAgICpcbiAgICogUGVybWlzc2lvbnM6IHN0YXJ0IGEgcGFja2FnZSBkZXBlbmRzIG9mIHRoZSBwdWJsaXNoIGFuZCB1bnB1Ymxpc2ggcGVybWlzc2lvbnMsIHRoZXJlIGlzIG5vIHNwZWNpZmljIGZsYWcgZm9yIHN0YXIgb3IgdW4gc3RhcnQuXG4gICAqIFRoZSBVUkwgZm9yIHN0YXIgaXMgc2ltaWxhciB0byB0aGUgdW5wdWJsaXNoIChjaGFuZ2UgcGFja2FnZSBmb3JtYXQpXG4gICAqXG4gICAqIG5wbSBoYXMgbm8gZW5wb2ludCBmb3Igc3RhciBhIHBhY2thZ2UsIHJhdGhlciBtdXRhdGUgdGhlIG1ldGFkYXRhIGFuZCBhY3RzIGFzLCB0aGUgZGlmZmVyZW5jZSBpcyB0aGVcbiAgICogdXNlcnMgcHJvcGVydHkgd2hpY2ggaXMgcGFydCBvZiB0aGUgcGF5bG9hZCBhbmQgdGhlIGJvZHkgb25seSBpbmNsdWRlc1xuICAgKlxuICAgKiB7XG5cdFx0ICBcIl9pZFwiOiBwa2dOYW1lLFxuXHQgIFx0XCJfcmV2XCI6IFwiMy1iMGNkYWVmYzliZGI3N2M4XCIsXG5cdFx0ICBcInVzZXJzXCI6IHtcblx0XHQgICAgW3VzZXJuYW1lXTogYm9vbGVhbiB2YWx1ZSAodHJ1ZSwgZmFsc2UpXG5cdFx0ICB9XG5cdH1cbiAgICpcbiAgICovXG4gIHJvdXRlci5wdXQoXG4gICAgJy86cGFja2FnZS86X3Jldj8vOnJldmlzaW9uPycsXG4gICAgY2FuKCdwdWJsaXNoJyksXG4gICAgbWVkaWEobWltZS5nZXRUeXBlKCdqc29uJykpLFxuICAgIGV4cGVjdEpzb24sXG4gICAgcHVibGlzaFBhY2thZ2Uoc3RvcmFnZSwgY29uZmlnLCBhdXRoKVxuICApO1xuXG4gIC8qKlxuICAgKiBVbi1wdWJsaXNoaW5nIGFuIGVudGlyZSBwYWNrYWdlLlxuICAgKlxuICAgKiBUaGlzIHNjZW5hcmlvIGhhcHBlbnMgd2hlbiB0aGUgZmlyc3QgY2FsbCBkZXRlY3QgdGhlcmUgaXMgb25seSBvbmUgdmVyc2lvbiByZW1haW5pbmdcbiAgICogaW4gdGhlIG1ldGFkYXRhLCB0aGVuIHRoZSBjbGllbnQgZGVjaWRlcyB0byBERUxFVEUgdGhlIHJlc291cmNlXG4gICAqIG5wbSBodHRwIGZldGNoIEdFVCAzMDQgaHR0cDovL2xvY2FsaG9zdDo0ODczL0BzY29wZSUyZnRlc3QxP3dyaXRlPXRydWUgMTA3Nm1zIChmcm9tIGNhY2hlKVxuICAgICBucG0gaHR0cCBmZXRjaCBERUxFVEUgMjAxIGh0dHA6Ly9sb2NhbGhvc3Q6NDg3My9Ac2NvcGUlMmZ0ZXN0MS8tcmV2LzE4LWQ4ZWJlMzAyMGJkNGFjOWMgMjJtc1xuICAgKi9cbiAgcm91dGVyLmRlbGV0ZSgnLzpwYWNrYWdlLy1yZXYvKicsIGNhbigndW5wdWJsaXNoJyksIHVuUHVibGlzaFBhY2thZ2Uoc3RvcmFnZSkpO1xuXG4gIC8vIHJlbW92aW5nIGEgdGFyYmFsbFxuICByb3V0ZXIuZGVsZXRlKFxuICAgICcvOnBhY2thZ2UvLS86ZmlsZW5hbWUvLXJldi86cmV2aXNpb24nLFxuICAgIGNhbigndW5wdWJsaXNoJyksXG4gICAgY2FuKCdwdWJsaXNoJyksXG4gICAgcmVtb3ZlVGFyYmFsbChzdG9yYWdlKVxuICApO1xuXG4gIC8vIHVwbG9hZGluZyBwYWNrYWdlIHRhcmJhbGxcbiAgcm91dGVyLnB1dChcbiAgICAnLzpwYWNrYWdlLy0vOmZpbGVuYW1lLyonLFxuICAgIGNhbigncHVibGlzaCcpLFxuICAgIG1lZGlhKEhFQURFUlMuT0NURVRfU1RSRUFNKSxcbiAgICB1cGxvYWRQYWNrYWdlVGFyYmFsbChzdG9yYWdlKVxuICApO1xuXG4gIC8vIG9ubHkgdXNlZCBmb3IgZGV2ZWxvcG1lbnRcbiAgaWYgKGNvbmZpZy5fZGVidWcpIHtcbiAgICAvLyBhZGRpbmcgYSB2ZXJzaW9uXG4gICAgcm91dGVyLnB1dChcbiAgICAgICcvOnBhY2thZ2UvOnZlcnNpb24vLXRhZy86dGFnJyxcbiAgICAgIGNhbigncHVibGlzaCcpLFxuICAgICAgbWVkaWEobWltZS5nZXRUeXBlKCdqc29uJykpLFxuICAgICAgZXhwZWN0SnNvbixcbiAgICAgIGFkZFZlcnNpb24oc3RvcmFnZSlcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogUHVibGlzaCBhIHBhY2thZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHB1Ymxpc2hQYWNrYWdlKHN0b3JhZ2U6IFN0b3JhZ2UsIGNvbmZpZzogQ29uZmlnLCBhdXRoOiBBdXRoKTogYW55IHtcbiAgY29uc3Qgc3RhckFwaSA9IHN0YXIoc3RvcmFnZSk7XG4gIHJldHVybiBmdW5jdGlvbiAocmVxOiAkUmVxdWVzdEV4dGVuZCwgcmVzOiAkUmVzcG9uc2VFeHRlbmQsIG5leHQ6ICROZXh0RnVuY3Rpb25WZXIpOiB2b2lkIHtcbiAgICBjb25zdCBwYWNrYWdlTmFtZSA9IHJlcS5wYXJhbXMucGFja2FnZTtcbiAgICBkZWJ1ZygncHVibGlzaGluZyBvciB1cGRhdGluZyBhIG5ldyB2ZXJzaW9uIGZvciAlbycsIHBhY2thZ2VOYW1lKTtcbiAgICAvKipcbiAgICAgKiBXcml0ZSB0YXJiYWxsIG9mIHN0cmVhbSBkYXRhIGZyb20gcGFja2FnZSBjbGllbnRzLlxuICAgICAqL1xuICAgIGNvbnN0IGNyZWF0ZVRhcmJhbGwgPSBmdW5jdGlvbiAoZmlsZW5hbWU6IHN0cmluZywgZGF0YSwgY2I6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgICBjb25zdCBzdHJlYW0gPSBzdG9yYWdlLmFkZFRhcmJhbGwocGFja2FnZU5hbWUsIGZpbGVuYW1lKTtcbiAgICAgIHN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGNiKGVycik7XG4gICAgICB9KTtcbiAgICAgIHN0cmVhbS5vbignc3VjY2VzcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2IoKTtcbiAgICAgIH0pO1xuICAgICAgLy8gdGhpcyBpcyBkdW1iIGFuZCBtZW1vcnktY29uc3VtaW5nLCBidXQgd2hhdCBjaG9pY2VzIGRvIHdlIGhhdmU/XG4gICAgICAvLyBmbG93OiB3ZSBuZWVkIGZpcnN0IHJlZmFjdG9yIHRoaXMgZmlsZSBiZWZvcmUgZGVjaWRlcyB3aGljaCB0eXBlIHVzZSBoZXJlXG4gICAgICBzdHJlYW0uZW5kKEJ1ZmZlci5mcm9tKGRhdGEuZGF0YSwgJ2Jhc2U2NCcpKTtcbiAgICAgIHN0cmVhbS5kb25lKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBuZXcgcGFja2FnZSB2ZXJzaW9uIGluIHN0b3JhZ2VcbiAgICAgKi9cbiAgICBjb25zdCBjcmVhdGVWZXJzaW9uID0gZnVuY3Rpb24gKHZlcnNpb246IHN0cmluZywgbWV0YWRhdGE6IFZlcnNpb24sIGNiOiBDYWxsYmFjayk6IHZvaWQge1xuICAgICAgc3RvcmFnZS5hZGRWZXJzaW9uKHBhY2thZ2VOYW1lLCB2ZXJzaW9uLCBtZXRhZGF0YSwgbnVsbCwgY2IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGQgbmV3IHRhZ3MgaW4gc3RvcmFnZVxuICAgICAqL1xuICAgIGNvbnN0IGFkZFRhZ3MgPSBmdW5jdGlvbiAodGFnczogTWVyZ2VUYWdzLCBjYjogQ2FsbGJhY2spOiB2b2lkIHtcbiAgICAgIHN0b3JhZ2UubWVyZ2VUYWdzKHBhY2thZ2VOYW1lLCB0YWdzLCBjYik7XG4gICAgfTtcblxuICAgIGNvbnN0IGFmdGVyQ2hhbmdlID0gZnVuY3Rpb24gKGVycm9yLCBva01lc3NhZ2UsIG1ldGFkYXRhKTogdm9pZCB7XG4gICAgICBjb25zdCBtZXRhZGF0YUNvcHk6IFBhY2thZ2UgPSB7IC4uLm1ldGFkYXRhIH07XG5cbiAgICAgIGNvbnN0IHsgX2F0dGFjaG1lbnRzLCB2ZXJzaW9ucyB9ID0gbWV0YWRhdGFDb3B5O1xuXG4gICAgICAvLyBgbnBtIHN0YXJgIHdvdWxkbid0IGhhdmUgYXR0YWNobWVudHNcbiAgICAgIC8vIGFuZCBgbnBtIGRlcHJlY2F0ZWAgd291bGQgaGF2ZSBhdHRhY2htZW50cyBhcyBhIGVtcHR5IG9iamVjdCwgaS5lIHt9XG4gICAgICBpZiAoXy5pc05pbChfYXR0YWNobWVudHMpIHx8IEpTT04uc3RyaW5naWZ5KF9hdHRhY2htZW50cykgPT09ICd7fScpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHQoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5zdGF0dXMoSFRUUF9TVEFUVVMuQ1JFQVRFRCk7XG4gICAgICAgIHJldHVybiBuZXh0KHtcbiAgICAgICAgICBvazogb2tNZXNzYWdlLFxuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBucG0tcmVnaXN0cnktY2xpZW50IDAuMysgZW1iZWRzIHRhcmJhbGwgaW50byB0aGUganNvbiB1cGxvYWRcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3MvbnBtLXJlZ2lzdHJ5LWNsaWVudC9jb21taXQvZTlmYmViOGI2N2YyNDkzOTRmNzM1Yzc0ZWYxMWZlNDcyMGQ0NmNhMFxuICAgICAgLy8gaXNzdWUgaHR0cHM6Ly9naXRodWIuY29tL3JsaWR3a2Evc2lub3BpYS9pc3N1ZXMvMzEsIGRlYWxpbmcgd2l0aCBpdCBoZXJlOlxuICAgICAgY29uc3QgaXNJbnZhbGlkQm9keUZvcm1hdCA9XG4gICAgICAgIGlzT2JqZWN0KF9hdHRhY2htZW50cykgPT09IGZhbHNlIHx8XG4gICAgICAgIGhhc0RpZmZPbmVLZXkoX2F0dGFjaG1lbnRzKSB8fFxuICAgICAgICBpc09iamVjdCh2ZXJzaW9ucykgPT09IGZhbHNlIHx8XG4gICAgICAgIGhhc0RpZmZPbmVLZXkodmVyc2lvbnMpO1xuXG4gICAgICBpZiAoaXNJbnZhbGlkQm9keUZvcm1hdCkge1xuICAgICAgICAvLyBucG0gaXMgZG9pbmcgc29tZXRoaW5nIHN0cmFuZ2UgYWdhaW5cbiAgICAgICAgLy8gaWYgdGhpcyBoYXBwZW5zIGluIG5vcm1hbCBjaXJjdW1zdGFuY2VzLCByZXBvcnQgaXQgYXMgYSBidWdcbiAgICAgICAgbG9nZ2VyLmluZm8oeyBwYWNrYWdlTmFtZSB9LCBgd3JvbmcgcGFja2FnZSBmb3JtYXQgb24gcHVibGlzaCBhIHBhY2thZ2UgQHtwYWNrYWdlTmFtZX1gKTtcbiAgICAgICAgcmV0dXJuIG5leHQoRXJyb3JDb2RlLmdldEJhZFJlcXVlc3QoQVBJX0VSUk9SLlVOU1VQT1JURURfUkVHSVNUUllfQ0FMTCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXJyb3IgJiYgZXJyb3Iuc3RhdHVzICE9PSBIVFRQX1NUQVRVUy5DT05GTElDVCkge1xuICAgICAgICByZXR1cm4gbmV4dChlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIC8vIGF0IHRoaXMgcG9pbnQgZG9jdW1lbnQgaXMgZWl0aGVyIGNyZWF0ZWQgb3IgZXhpc3RlZCBiZWZvcmVcbiAgICAgIGNvbnN0IFtmaXJzdEF0dGFjaG1lbnRLZXldID0gT2JqZWN0LmtleXMoX2F0dGFjaG1lbnRzKTtcblxuICAgICAgY3JlYXRlVGFyYmFsbChcbiAgICAgICAgUGF0aC5iYXNlbmFtZShmaXJzdEF0dGFjaG1lbnRLZXkpLFxuICAgICAgICBfYXR0YWNobWVudHNbZmlyc3RBdHRhY2htZW50S2V5XSxcbiAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dChlcnJvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgdmVyc2lvblRvUHVibGlzaCA9IE9iamVjdC5rZXlzKHZlcnNpb25zKVswXTtcbiAgICAgICAgICBjb25zdCB2ZXJzaW9uTWV0YWRhdGFUb1B1Ymxpc2ggPSB2ZXJzaW9uc1t2ZXJzaW9uVG9QdWJsaXNoXTtcblxuICAgICAgICAgIHZlcnNpb25NZXRhZGF0YVRvUHVibGlzaC5yZWFkbWUgPVxuICAgICAgICAgICAgXy5pc05pbCh2ZXJzaW9uTWV0YWRhdGFUb1B1Ymxpc2gucmVhZG1lKSA9PT0gZmFsc2VcbiAgICAgICAgICAgICAgPyBTdHJpbmcodmVyc2lvbk1ldGFkYXRhVG9QdWJsaXNoLnJlYWRtZSlcbiAgICAgICAgICAgICAgOiAnJztcblxuICAgICAgICAgIGNyZWF0ZVZlcnNpb24odmVyc2lvblRvUHVibGlzaCwgdmVyc2lvbk1ldGFkYXRhVG9QdWJsaXNoLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dChlcnJvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFkZFRhZ3MobWV0YWRhdGFDb3B5W0RJU1RfVEFHU10sIGFzeW5jIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dChlcnJvcik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG5vdGlmeShcbiAgICAgICAgICAgICAgICAgIG1ldGFkYXRhQ29weSxcbiAgICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgIHJlcS5yZW1vdGVfdXNlcixcbiAgICAgICAgICAgICAgICAgIGAke21ldGFkYXRhQ29weS5uYW1lfUAke3ZlcnNpb25Ub1B1Ymxpc2h9YFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKHsgZXJyb3IgfSwgJ25vdGlmeSBiYXRjaCBzZXJ2aWNlIGhhcyBmYWlsZWQ6IEB7ZXJyb3J9Jyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXMuc3RhdHVzKEhUVFBfU1RBVFVTLkNSRUFURUQpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dCh7IG9rOiBva01lc3NhZ2UsIHN1Y2Nlc3M6IHRydWUgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgaWYgKGlzUHVibGlzaGFibGVQYWNrYWdlKHJlcS5ib2R5KSA9PT0gZmFsc2UgJiYgaXNPYmplY3QocmVxLmJvZHkudXNlcnMpKSB7XG4gICAgICByZXR1cm4gc3RhckFwaShyZXEsIHJlcywgbmV4dCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gdmFsaWRhdGlvblV0aWxzLm5vcm1hbGl6ZU1ldGFkYXRhKHJlcS5ib2R5LCBwYWNrYWdlTmFtZSk7XG4gICAgICAvLyBjaGVjayBfYXR0YWNobWVudHMgdG8gZGlzdGluZ3Vpc2ggcHVibGlzaCBhbmQgZGVwcmVjYXRlXG4gICAgICBpZiAoXG4gICAgICAgIHJlcS5wYXJhbXMuX3JldiB8fFxuICAgICAgICAoaXNSZWxhdGVkVG9EZXByZWNhdGlvbihyZXEuYm9keSkgJiYgXy5pc0VtcHR5KHJlcS5ib2R5Ll9hdHRhY2htZW50cykpXG4gICAgICApIHtcbiAgICAgICAgZGVidWcoJ3VwZGF0aW5nIGEgbmV3IHZlcnNpb24gZm9yICVvJywgcGFja2FnZU5hbWUpO1xuICAgICAgICAvLyB3ZSBjaGVjayB1bnB1Ymxpc2ggcGVybWlzc2lvbnMsIGFuIHVwZGF0ZSBpcyBiYXNpY2FsbHkgcmVtb3ZlIHZlcnNpb25zXG4gICAgICAgIGNvbnN0IHJlbW90ZSA9IHJlcS5yZW1vdGVfdXNlcjtcbiAgICAgICAgYXV0aC5hbGxvd191bnB1Ymxpc2goeyBwYWNrYWdlTmFtZSB9LCByZW1vdGUsIChlcnJvcikgPT4ge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKHsgcGFja2FnZU5hbWUgfSwgYG5vdCBhbGxvd2VkIHRvIHVucHVibGlzaCBhIHZlcnNpb24gZm9yIEB7cGFja2FnZU5hbWV9YCk7XG4gICAgICAgICAgICByZXR1cm4gbmV4dChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0b3JhZ2UuY2hhbmdlUGFja2FnZShwYWNrYWdlTmFtZSwgbWV0YWRhdGEsIHJlcS5wYXJhbXMucmV2aXNpb24sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgYWZ0ZXJDaGFuZ2UoZXJyb3IsIEFQSV9NRVNTQUdFLlBLR19DSEFOR0VELCBtZXRhZGF0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ2FkZGluZyBhIG5ldyB2ZXJzaW9uIGZvciAlbycsIHBhY2thZ2VOYW1lKTtcbiAgICAgICAgc3RvcmFnZS5hZGRQYWNrYWdlKHBhY2thZ2VOYW1lLCBtZXRhZGF0YSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgYWZ0ZXJDaGFuZ2UoZXJyb3IsIEFQSV9NRVNTQUdFLlBLR19DUkVBVEVELCBtZXRhZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoeyBwYWNrYWdlTmFtZSB9LCAnZXJyb3Igb24gcHVibGlzaCwgYmFkIHBhY2thZ2UgZGF0YSBmb3IgQHtwYWNrYWdlTmFtZX0nKTtcbiAgICAgIHJldHVybiBuZXh0KEVycm9yQ29kZS5nZXRCYWREYXRhKEFQSV9FUlJPUi5CQURfUEFDS0FHRV9EQVRBKSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIHVuLXB1Ymxpc2ggYSBwYWNrYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1blB1Ymxpc2hQYWNrYWdlKHN0b3JhZ2U6IFN0b3JhZ2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXE6ICRSZXF1ZXN0RXh0ZW5kLCByZXM6ICRSZXNwb25zZUV4dGVuZCwgbmV4dDogJE5leHRGdW5jdGlvblZlcik6IHZvaWQge1xuICAgIGNvbnN0IHBhY2thZ2VOYW1lID0gcmVxLnBhcmFtcy5wYWNrYWdlO1xuICAgIGRlYnVnKCd1bnB1Ymxpc2hpbmcgJW8nLCBwYWNrYWdlTmFtZSk7XG4gICAgc3RvcmFnZS5yZW1vdmVQYWNrYWdlKHBhY2thZ2VOYW1lLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBuZXh0KGVycik7XG4gICAgICB9XG4gICAgICByZXMuc3RhdHVzKEhUVFBfU1RBVFVTLkNSRUFURUQpO1xuICAgICAgcmV0dXJuIG5leHQoeyBvazogQVBJX01FU1NBR0UuUEtHX1JFTU9WRUQgfSk7XG4gICAgfSk7XG4gIH07XG59XG5cbi8qKlxuICogRGVsZXRlIHRhcmJhbGxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVRhcmJhbGwoc3RvcmFnZTogU3RvcmFnZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHJlcTogJFJlcXVlc3RFeHRlbmQsIHJlczogJFJlc3BvbnNlRXh0ZW5kLCBuZXh0OiAkTmV4dEZ1bmN0aW9uVmVyKTogdm9pZCB7XG4gICAgY29uc3QgcGFja2FnZU5hbWUgPSByZXEucGFyYW1zLnBhY2thZ2U7XG4gICAgY29uc3QgeyBmaWxlbmFtZSwgcmV2aXNpb24gfSA9IHJlcS5wYXJhbXM7XG4gICAgZGVidWcoJ3JlbW92aW5nIGEgdGFyYmFsbCBmb3IgJW8tJW8tJW8nLCBwYWNrYWdlTmFtZSwgZmlsZW5hbWUsIHJldmlzaW9uKTtcbiAgICBzdG9yYWdlLnJlbW92ZVRhcmJhbGwocGFja2FnZU5hbWUsIGZpbGVuYW1lLCByZXZpc2lvbiwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gbmV4dChlcnIpO1xuICAgICAgfVxuICAgICAgcmVzLnN0YXR1cyhIVFRQX1NUQVRVUy5DUkVBVEVEKTtcbiAgICAgIGRlYnVnKCdzdWNjZXNzIHJlbW92ZSB0YXJiYWxsIGZvciAlby0lby0lbycsIHBhY2thZ2VOYW1lLCBmaWxlbmFtZSwgcmV2aXNpb24pO1xuICAgICAgcmV0dXJuIG5leHQoeyBvazogQVBJX01FU1NBR0UuVEFSQkFMTF9SRU1PVkVEIH0pO1xuICAgIH0pO1xuICB9O1xufVxuLyoqXG4gKiBBZGRzIGEgbmV3IHZlcnNpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFZlcnNpb24oc3RvcmFnZTogU3RvcmFnZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHJlcTogJFJlcXVlc3RFeHRlbmQsIHJlczogJFJlc3BvbnNlRXh0ZW5kLCBuZXh0OiAkTmV4dEZ1bmN0aW9uVmVyKTogdm9pZCB7XG4gICAgY29uc3QgeyB2ZXJzaW9uLCB0YWcgfSA9IHJlcS5wYXJhbXM7XG4gICAgY29uc3QgcGFja2FnZU5hbWUgPSByZXEucGFyYW1zLnBhY2thZ2U7XG5cbiAgICBzdG9yYWdlLmFkZFZlcnNpb24ocGFja2FnZU5hbWUsIHZlcnNpb24sIHJlcS5ib2R5LCB0YWcsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXh0KGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmVzLnN0YXR1cyhIVFRQX1NUQVRVUy5DUkVBVEVEKTtcbiAgICAgIHJldHVybiBuZXh0KHtcbiAgICAgICAgb2s6IEFQSV9NRVNTQUdFLlBLR19QVUJMSVNIRUQsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn1cblxuLyoqXG4gKiB1cGxvYWRQYWNrYWdlVGFyYmFsbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBsb2FkUGFja2FnZVRhcmJhbGwoc3RvcmFnZTogU3RvcmFnZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHJlcTogJFJlcXVlc3RFeHRlbmQsIHJlczogJFJlc3BvbnNlRXh0ZW5kLCBuZXh0OiAkTmV4dEZ1bmN0aW9uVmVyKTogdm9pZCB7XG4gICAgY29uc3QgcGFja2FnZU5hbWUgPSByZXEucGFyYW1zLnBhY2thZ2U7XG4gICAgY29uc3Qgc3RyZWFtID0gc3RvcmFnZS5hZGRUYXJiYWxsKHBhY2thZ2VOYW1lLCByZXEucGFyYW1zLmZpbGVuYW1lKTtcbiAgICByZXEucGlwZShzdHJlYW0pO1xuXG4gICAgLy8gY2hlY2tpbmcgaWYgZW5kIGV2ZW50IGNhbWUgYmVmb3JlIGNsb3NpbmdcbiAgICBsZXQgY29tcGxldGUgPSBmYWxzZTtcbiAgICByZXEub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5kb25lKCk7XG4gICAgfSk7XG5cbiAgICByZXEub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFjb21wbGV0ZSkge1xuICAgICAgICBzdHJlYW0uYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICByZXR1cm4gcmVzLmxvY2Fscy5yZXBvcnRfZXJyb3IoZXJyKTtcbiAgICB9KTtcblxuICAgIHN0cmVhbS5vbignc3VjY2VzcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlcy5zdGF0dXMoSFRUUF9TVEFUVVMuQ1JFQVRFRCk7XG4gICAgICByZXR1cm4gbmV4dCh7XG4gICAgICAgIG9rOiBBUElfTUVTU0FHRS5UQVJCQUxMX1VQTE9BREVELFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUEsSUFBQUEsTUFBQSxHQUFBQyxzQkFBQSxDQUFBQyxPQUFBO0FBRUEsSUFBQUMsT0FBQSxHQUFBRixzQkFBQSxDQUFBQyxPQUFBO0FBQ0EsSUFBQUUsS0FBQSxHQUFBSCxzQkFBQSxDQUFBQyxPQUFBO0FBQ0EsSUFBQUcsS0FBQSxHQUFBSixzQkFBQSxDQUFBQyxPQUFBO0FBRUEsSUFBQUksS0FBQSxHQUFBSixPQUFBO0FBQ0EsSUFBQUssV0FBQSxHQUFBTCxPQUFBO0FBSUEsSUFBQU0sVUFBQSxHQUFBTixPQUFBO0FBQ0EsSUFBQU8sT0FBQSxHQUFBUCxPQUFBO0FBQ0EsSUFBQVEsT0FBQSxHQUFBUixPQUFBO0FBRUEsSUFBQVMsYUFBQSxHQUFBVCxPQUFBO0FBQ0EsSUFBQVUsTUFBQSxHQUFBVixPQUFBO0FBRUEsSUFBQVcsS0FBQSxHQUFBWixzQkFBQSxDQUFBQyxPQUFBO0FBQTBCLFNBQUFELHVCQUFBYSxDQUFBLFdBQUFBLENBQUEsSUFBQUEsQ0FBQSxDQUFBQyxVQUFBLEdBQUFELENBQUEsS0FBQUUsT0FBQSxFQUFBRixDQUFBO0FBQUEsU0FBQUcsUUFBQUgsQ0FBQSxFQUFBSSxDQUFBLFFBQUFDLENBQUEsR0FBQUMsTUFBQSxDQUFBQyxJQUFBLENBQUFQLENBQUEsT0FBQU0sTUFBQSxDQUFBRSxxQkFBQSxRQUFBQyxDQUFBLEdBQUFILE1BQUEsQ0FBQUUscUJBQUEsQ0FBQVIsQ0FBQSxHQUFBSSxDQUFBLEtBQUFLLENBQUEsR0FBQUEsQ0FBQSxDQUFBQyxNQUFBLFdBQUFO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