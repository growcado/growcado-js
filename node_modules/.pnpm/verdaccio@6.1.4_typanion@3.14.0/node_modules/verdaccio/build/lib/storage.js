"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _assert = _interopRequireDefault(require("assert"));
var _async = _interopRequireDefault(require("async"));
var _debug = _interopRequireDefault(require("debug"));
var _lodash = _interopRequireDefault(require("lodash"));
var _stream = _interopRequireDefault(require("stream"));
var _config = require("@verdaccio/config");
var _core = require("@verdaccio/core");
var _loaders = require("@verdaccio/loaders");
var _localStorageLegacy = _interopRequireDefault(require("@verdaccio/local-storage-legacy"));
var _searchIndexer = require("@verdaccio/search-indexer");
var _streams = require("@verdaccio/streams");
var _logger = require("../lib/logger");
var _constants = require("./constants");
var _localStorage = _interopRequireDefault(require("./local-storage"));
var _metadataUtils = require("./metadata-utils");
var _storageUtils = require("./storage-utils");
var _upStorage = _interopRequireDefault(require("./up-storage"));
var _uplinkUtil = require("./uplink-util");
var _utils = require("./utils");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const debug = (0, _debug.default)('verdaccio:storage');
class Storage {
  constructor(config) {
    _defineProperty(this, "localStorage", void 0);
    _defineProperty(this, "config", void 0);
    _defineProperty(this, "logger", void 0);
    _defineProperty(this, "uplinks", void 0);
    _defineProperty(this, "filters", void 0);
    this.config = config;
    this.uplinks = (0, _uplinkUtil.setupUpLinks)(config);
    this.logger = _logger.logger;
    this.filters = [];
    // @ts-ignore
    this.localStorage = null;
  }
  async init(config, filters = []) {
    if (this.localStorage === null) {
      this.filters = filters;
      const storageInstance = await this.loadStorage(config, this.logger);
      this.localStorage = new _localStorage.default(this.config, _logger.logger, storageInstance);
      await this.localStorage.getSecret(config);
      debug('initialization completed');
    } else {
      debug('storage has been already initialized');
    }
    if (!this.filters) {
      var _this$config, _this$config$serverSe;
      this.filters = await (0, _loaders.asyncLoadPlugin)(this.config.filters, {
        config: this.config,
        logger: this.logger
      }, plugin => {
        return typeof plugin.filter_metadata !== 'undefined';
      }, true, (_this$config = this.config) === null || _this$config === void 0 ? void 0 : (_this$config$serverSe = _this$config.serverSettings) === null || _this$config$serverSe === void 0 ? void 0 : _this$config$serverSe.pluginPrefix, _core.PLUGIN_CATEGORY.FILTER);
      debug('filters available %o', this.filters.length);
    }
  }
  async loadStorage(config, logger) {
    const Storage = await this.loadStorePlugin();
    if (_lodash.default.isNil(Storage)) {
      (0, _assert.default)(this.config.storage, 'CONFIG: storage path not defined');
      debug('no custom storage found, loading default storage @verdaccio/local-storage');
      const localStorage = new _localStorageLegacy.default(config, logger);
      logger.info({
        name: '@verdaccio/local-storage',
        pluginCategory: _core.PLUGIN_CATEGORY.STORAGE
      }, 'plugin @{name} successfully loaded (@{pluginCategory})');
      return localStorage;
    }
    return Storage;
  }
  async loadStorePlugin() {
    var _this$config2, _this$config2$serverS;
    const plugins = await (0, _loaders.asyncLoadPlugin)(this.config.store, {
      config: this.config,
      logger: this.logger
    }, plugin => {
      return typeof plugin.getPackageStorage !== 'undefined';
    }, true, (_this$config2 = this.config) === null || _this$config2 === void 0 ? void 0 : (_this$config2$serverS = _this$config2.serverSettings) === null || _this$config2$serverS === void 0 ? void 0 : _this$config2$serverS.pluginPrefix, _core.PLUGIN_CATEGORY.STORAGE);
    if (plugins.length > 1) {
      this.logger.warn('more than one storage plugins has been detected, multiple storage are not supported, one will be selected automatically');
    }
    return _lodash.default.head(plugins);
  }

  /**
   *  Add a {name} package to a system
   Function checks if package with the same name is available from uplinks.
   If it isn't, we create package locally
   Used storages: local (write) && uplinks
   */
  async addPackage(name, metadata, callback) {
    try {
      await (0, _storageUtils.checkPackageLocal)(name, this.localStorage);
      await (0, _storageUtils.checkPackageRemote)(name, this._isAllowPublishOffline(), this._syncUplinksMetadata.bind(this));
      await (0, _storageUtils.publishPackage)(name, metadata, this.localStorage);
      callback();
    } catch (err) {
      callback(err);
    }
  }
  _isAllowPublishOffline() {
    return typeof this.config.publish !== 'undefined' && _lodash.default.isBoolean(this.config.publish.allow_offline) && this.config.publish.allow_offline;
  }
  readTokens(filter) {
    return this.localStorage.readTokens(filter);
  }
  saveToken(token) {
    return this.localStorage.saveToken(token);
  }
  deleteToken(user, tokenKey) {
    return this.localStorage.deleteToken(user, tokenKey);
  }

  /**
   * Add a new version of package {name} to a system
   Used storages: local (write)
   */
  addVersion(name, version, metadata, tag, callback) {
    this.localStorage.addVersion(name, version, metadata, tag, callback);
  }

  /**
   * Tags a package version with a provided tag
   Used storages: local (write)
   */
  mergeTags(name, tagHash, callback) {
    this.localStorage.mergeTags(name, tagHash, callback);
  }

  /**
   * Change an existing package (i.e. unpublish one version)
   Function changes a package info from local storage and all uplinks with write access./
   Used storages: local (write)
   */
  changePackage(name, metadata, revision, callback) {
    this.localStorage.changePackage(name, metadata, revision, callback);
  }

  /**
   * Remove a package from a system
   Function removes a package from local storage
   Used storages: local (write)
   */
  removePackage(name, callback) {
    this.localStorage.removePackage(name, callback);
    // update the indexer
    _searchIndexer.SearchMemoryIndexer.remove(name).catch(reason => {
      _logger.logger.error('indexer has failed on remove item');
    });
  }

  /**
   Remove a tarball from a system
   Function removes a tarball from local storage.
   Tarball in question should not be linked to in any existing
   versions, i.e. package version should be unpublished first.
   Used storage: local (write)
   */
  removeTarball(name, filename, revision, callback) {
    this.localStorage.removeTarball(name, filename, revision, callback);
  }

  /**
   * Upload a tarball for {name} package
   Function is synchronous and returns a WritableStream
   Used storages: local (write)
   */
  addTarball(name, filename) {
    return this.localStorage.addTarball(name, filename);
  }
  hasLocalTarball(name, filename) {
    const self = this;
    return new Promise((resolve, reject) => {
      let localStream = self.localStorage.getTarball(name, filename);
      let isOpen = false;
      localStream.on('error', err => {
        if (isOpen || err.status !== _constants.HTTP_STATUS.NOT_FOUND) {
          reject(err);
        }
        // local reported 404 or request was aborted already
        if (localStream) {
          localStream.abort();
          localStream = null;
        }
        resolve(false);
      });
      localStream.on('open', function () {
        isOpen = true;
        localStream.abort();
        localStream = null;
        resolve(true);
      });
    });
  }

  /**
   Get a tarball from a storage for {name} package
   Function is synchronous and returns a ReadableStream
   Function tries to read tarball locally, if it fails then it reads package
   information in order to figure out where we can get this tarball from
   Used storages: local || uplink (just one)
   */
  getTarball(name, filename) {
    const readStream = new _streams.ReadTarball({});
    readStream.abort = function () {};
    const self = this;

    // if someone requesting tarball, it means that we should already have some
    // information about it, so fetching package info is unnecessary

    // trying local first
    // flow: should be IReadTarball
    let localStream = self.localStorage.getTarball(name, filename);
    let isOpen = false;
    localStream.on('error', err => {
      if (isOpen || err.status !== _constants.HTTP_STATUS.NOT_FOUND) {
        return readStream.emit('error', err);
      }

      // local reported 404
      const err404 = err;
      localStream.abort();
      localStream = null; // we force for garbage collector
      self.localStorage.getPackageMetadata(name, (err, info) => {
        if (_lodash.default.isNil(err) && info._distfiles && _lodash.default.isNil(info._distfiles[filename]) === false) {
          // information about this file exists locally
          serveFile(info._distfiles[filename]);
        } else {
          // we know nothing about this file, trying to get information elsewhere
          self._syncUplinksMetadata(name, info, {}, (err, info) => {
            if (_lodash.default.isNil(err) === false) {
              return readStream.emit('error', err);
            }
            if (_lodash.default.isNil(info._distfiles) || _lodash.default.isNil(info._distfiles[filename])) {
              return readStream.emit('error', err404);
            }
            serveFile(info._distfiles[filename]);
          });
        }
      });
    });
    localStream.on('content-length', function (v) {
      readStream.emit('content-length', v);
    });
    localStream.on('open', function () {
      isOpen = true;
      localStream.pipe(readStream);
    });
    return readStream;

    /**
     * Fetch and cache local/remote packages.
     * @param {Object} file define the package shape
     */
    function serveFile(file) {
      let uplink = null;
      for (const uplinkId in self.uplinks) {
        if ((0, _config.hasProxyTo)(name, uplinkId, self.config.packages)) {
          uplink = self.uplinks[uplinkId];
        }
      }
      if (uplink == null) {
        uplink = new _upStorage.default({
          url: file.url,
          cache: true,
          _autogenerated: true
        }, self.config);
      }
      let savestream = null;
      if (uplink.config.cache) {
        savestream = self.localStorage.addTarball(name, filename);
      }
      let on_open = function () {
        // prevent it from being called twice
        on_open = function () {};
        const rstream2 = uplink.fetchTarball(file.url);
        rstream2.on('error', function (err) {
          if (savestream) {
            savestream.abort();
          }
          savestream = null;
          readStream.emit('error', err);
        });
        rstream2.on('end', function () {
          if (savestream) {
            savestream.done();
          }
        });
        rstream2.on('content-length', function (v) {
          readStream.emit('content-length', v);
          if (savestream) {
            savestream.emit('content-length', v);
          }
        });
        rstream2.pipe(readStream);
        if (savestream) {
          rstream2.pipe(savestream);
        }
      };
      if (savestream) {
        savestream.on('open', function () {
          on_open();
        });
        savestream.on('error', function (err) {
          self.logger.warn({
            err: err,
            fileName: file
          }, 'error saving file @{fileName}: @{err.message}\n@{err.stack}');
          if (savestream) {
            savestream.abort();
          }
          savestream = null;
          on_open();
        });
      } else {
        on_open();
      }
    }
  }

  /**
   Retrieve a package metadata for {name} package
   Function invokes localStorage.getPackage and uplink.get_package for every
   uplink with proxy_access rights against {name} and combines results
   into one json object
   Used storages: local && uplink (proxy_access)
    * @param {object} options
   * @property {string} options.name Package Name
   * @property {object}  options.req Express `req` object
   * @property {boolean} options.keepUpLinkData keep up link info in package meta, last update, etc.
   * @property {function} options.callback Callback for receive data
   */
  getPackage(options) {
    this.localStorage.getPackageMetadata(options.name, (err, data) => {
      if (err && (!err.status || err.status >= _constants.HTTP_STATUS.INTERNAL_ERROR)) {
        // report internal errors right away
        return options.callback(err);
      }
      this._syncUplinksMetadata(options.name, data, {
        req: options.req,
        uplinksLook: options.uplinksLook
      }, function getPackageSynUpLinksCallback(err, result, uplinkErrors) {
        if (err) {
          return options.callback(err);
        }
        (0, _utils.normalizeDistTags)((0, _storageUtils.cleanUpLinksRef)(options.keepUpLinkData, result));

        // npm can throw if this field doesn't exist
        result._attachments = {};
        if (options.abbreviated === true) {
          options.callback(null, (0, _storageUtils.convertAbbreviatedManifest)(result), uplinkErrors);
        } else {
          options.callback(null, result, uplinkErrors);
        }
      });
    });
  }

  /**
   Retrieve remote and local packages more recent than {startkey}
   Function streams all packages from all uplinks first, and then
   local packages.
   Note that local packages could override registry ones just because
   they appear in JSON last. That's a trade-off we make to avoid
   memory issues.
   Used storages: local && uplink (proxy_access)
   * @param {*} startkey
   * @param {*} options
   * @return {Stream}
   */
  search(startkey, options) {
    const self = this;
    const searchStream = new _stream.default.PassThrough({
      objectMode: true
    });
    _async.default.eachSeries(Object.keys(this.uplinks), function (up_name, cb) {
      var _options$req, _options$req$query;
      // shortcut: if `local=1` is supplied, don't call uplinks
      if (((_options$req = options.req) === null || _options$req === void 0 ? void 0 : (_options$req$query = _options$req.query) === null || _options$req$query === void 0 ? void 0 : _options$req$query.local) !== undefined) {
        return cb();
      }
      _logger.logger.info(`search for uplink ${up_name}`);
      // search by keyword for each uplink
      const uplinkStream = self.uplinks[up_name].search(options);
      // join uplink stream with streams PassThrough
      uplinkStream.pipe(searchStream, {
        end: false
      });
      uplinkStream.on('error', function (err) {
        self.logger.error({
          err: err
        }, 'uplink error: @{err.message}');
        cb();
        // to avoid call callback more than once
        cb = function () {};
      });
      uplinkStream.on('end', function () {
        cb();
        // to avoid call callback more than once
        cb = function () {};
      });
      searchStream.abort = function () {
        if (uplinkStream.abort) {
          uplinkStream.abort();
        }
        cb();
        // to avoid call callback more than once
        cb = function () {};
      };
    },
    // executed after all series
    function () {
      // attach a local search results
      const localSearchStream = self.localStorage.search(startkey, options);
      searchStream.abort = function () {
        localSearchStream.abort();
      };
      localSearchStream.pipe(searchStream, {
        end: true
      });
      localSearchStream.on('error', function (err) {
        self.logger.error({
          err: err
        }, 'search error: @{err.message}');
        searchStream.end();
      });
    });
    return searchStream;
  }

  /**
   * Retrieve only private local packages
   * @param {*} callback
   */
  getLocalDatabase(callback) {
    const self = this;
    this.localStorage.storagePlugin.get((err, locals) => {
      if (err) {
        callback(err);
      }
      const packages = [];
      const getPackage = function (itemPkg) {
        self.localStorage.getPackageMetadata(locals[itemPkg], function (err, pkgMetadata) {
          if (_lodash.default.isNil(err)) {
            const latest = pkgMetadata[_constants.DIST_TAGS].latest;
            if (latest && pkgMetadata.versions[latest]) {
              const version = pkgMetadata.versions[latest];
              const timeList = pkgMetadata.time;
              const time = timeList[latest];
              // @ts-ignore
              version.time = time;

              // Add for stars api
              // @ts-ignore
              version.users = pkgMetadata.users;
              packages.push(version);
            } else {
              self.logger.warn({
                package: locals[itemPkg]
              }, 'package @{package} does not have a "latest" tag?');
            }
          }
          if (itemPkg >= locals.length - 1) {
            callback(null, packages);
          } else {
            getPackage(itemPkg + 1);
          }
        });
      };
      if (locals.length) {
        getPackage(0);
      } else {
        callback(null, []);
      }
    });
  }

  /**
   * Function fetches package metadata from uplinks and synchronizes it with local data
   if package is available locally, it MUST be provided in pkginfo
   returns callback(err, result, uplink_errors)
   */
  _syncUplinksMetadata(name, packageInfo, options, callback) {
    let found = true;
    const self = this;
    const upLinks = [];
    const hasToLookIntoUplinks = _lodash.default.isNil(options.uplinksLook) || options.uplinksLook;
    if (!packageInfo) {
      found = false;
      packageInfo = (0, _storageUtils.generatePackageTemplate)(name);
    }
    for (const uplink in this.uplinks) {
      if ((0, _config.hasProxyTo)(name, uplink, this.config.packages) && hasToLookIntoUplinks) {
        upLinks.push(this.uplinks[uplink]);
      }
    }
    _async.default.map(upLinks, (upLink, cb) => {
      const _options = Object.assign({}, options);
      const upLinkMeta = packageInfo._uplinks[upLink.upname];
      if ((0, _utils.isObject)(upLinkMeta)) {
        const fetched = upLinkMeta.fetched;
        if (fetched && Date.now() - fetched < upLink.maxage) {
          return cb();
        }
        _options.etag = upLinkMeta.etag;
      }
      upLink.getRemoteMetadata(name, _options, (err, upLinkResponse, eTag) => {
        if (err && err.remoteStatus === 304) {
          upLinkMeta.fetched = Date.now();
        }
        if (err || !upLinkResponse) {
          return cb(null, [err || _utils.ErrorCode.getInternalError('no data')]);
        }
        try {
          upLinkResponse = _core.validationUtils.normalizeMetadata(upLinkResponse, name);
        } catch (err) {
          self.logger.error({
            sub: 'out',
            err: err
          }, 'package.json validating error @{!err.message}\n@{err.stack}');
          return cb(null, [err]);
        }
        packageInfo._uplinks[upLink.upname] = {
          etag: eTag,
          fetched: Date.now()
        };
        packageInfo = (0, _storageUtils.mergeUplinkTimeIntoLocal)(packageInfo, upLinkResponse);
        (0, _uplinkUtil.updateVersionsHiddenUpLink)(upLinkResponse.versions, upLink);
        try {
          (0, _metadataUtils.mergeVersions)(packageInfo, upLinkResponse);
        } catch (err) {
          self.logger.error({
            sub: 'out',
            err: err
          }, 'package.json parsing error @{!err.message}\n@{err.stack}');
          return cb(null, [err]);
        }

        // if we got to this point, assume that the correct package exists
        // on the uplink
        found = true;
        cb();
      });
    },
    // @ts-ignore
    (err, upLinksErrors) => {
      (0, _assert.default)(!err && Array.isArray(upLinksErrors));

      // Check for connection timeout or reset errors with uplink(s)
      // (these should be handled differently from the package not being found)
      if (!found) {
        let uplinkTimeoutError;
        for (let i = 0; i < upLinksErrors.length; i++) {
          if (upLinksErrors[i]) {
            for (let j = 0; j < upLinksErrors[i].length; j++) {
              if (upLinksErrors[i][j]) {
                const code = upLinksErrors[i][j].code;
                if (code === 'ETIMEDOUT' || code === 'ESOCKETTIMEDOUT' || code === 'ECONNRESET') {
                  uplinkTimeoutError = true;
                  break;
                }
              }
            }
          }
        }
        if (uplinkTimeoutError) {
          return callback(_utils.ErrorCode.getServiceUnavailable(), null, upLinksErrors);
        }
        return callback(_utils.ErrorCode.getNotFound(_constants.API_ERROR.NO_PACKAGE), null, upLinksErrors);
      }
      if (upLinks.length === 0) {
        return callback(null, packageInfo);
      }
      self.localStorage.updateVersions(name, packageInfo, async (err, packageJsonLocal) => {
        if (err) {
          return callback(err);
        }
        // Any error here will cause a 404, like an uplink error. This is likely the right thing to do
        // as a broken filter is a security risk.
        const filterErrors = [];
        // This MUST be done serially and not in parallel as they modify packageJsonLocal
        for (const filter of self.filters) {
          try {
            // These filters can assume it's save to modify packageJsonLocal and return it directly for
            // performance (i.e. need not be pure)
            packageJsonLocal = await filter.filter_metadata(packageJsonLocal);
          } catch (err) {
            filterErrors.push(err);
          }
        }
        callback(null, packageJsonLocal, _lodash.default.concat(upLinksErrors, filterErrors));
      });
    });
  }

  /**
   * Set a hidden value for each version.
   * @param {Array} versions list of version
   * @param {String} upLink uplink name
   * @private
   */
  _updateVersionsHiddenUpLink(versions, upLink) {
    for (const i in versions) {
      if (Object.prototype.hasOwnProperty.call(versions, i)) {
        const version = versions[i];

        // holds a "hidden" value to be used by the package storage.
        version[Symbol.for('__verdaccio_uplink')] = upLink.upname;
      }
    }
  }
}
var _default = exports.default = Storage;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfYXNzZXJ0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfYXN5bmMiLCJfZGVidWciLCJfbG9kYXNoIiwiX3N0cmVhbSIsIl9jb25maWciLCJfY29yZSIsIl9sb2FkZXJzIiwiX2xvY2FsU3RvcmFnZUxlZ2FjeSIsIl9zZWFyY2hJbmRleGVyIiwiX3N0cmVhbXMiLCJfbG9nZ2VyIiwiX2NvbnN0YW50cyIsIl9sb2NhbFN0b3JhZ2UiLCJfbWV0YWRhdGFVdGlscyIsIl9zdG9yYWdlVXRpbHMiLCJfdXBTdG9yYWdlIiwiX3VwbGlua1V0aWwiLCJfdXRpbHMiLCJlIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJfZGVmaW5lUHJvcGVydHkiLCJyIiwidCIsIl90b1Byb3BlcnR5S2V5IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImkiLCJfdG9QcmltaXRpdmUiLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsImNhbGwiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJkZWJ1ZyIsImJ1aWxkRGVidWciLCJTdG9yYWdlIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJ1cGxpbmtzIiwic2V0dXBVcExpbmtzIiwibG9nZ2VyIiwiZmlsdGVycyIsImxvY2FsU3RvcmFnZSIsImluaXQiLCJzdG9yYWdlSW5zdGFuY2UiLCJsb2FkU3RvcmFnZSIsIkxvY2FsU3RvcmFnZSIsImdldFNlY3JldCIsIl90aGlzJGNvbmZpZyIsIl90aGlzJGNvbmZpZyRzZXJ2ZXJTZSIsImFzeW5jTG9hZFBsdWdpbiIsInBsdWdpbiIsImZpbHRlcl9tZXRhZGF0YSIsInNlcnZlclNldHRpbmdzIiwicGx1Z2luUHJlZml4IiwiUExVR0lOX0NBVEVHT1JZIiwiRklMVEVSIiwibGVuZ3RoIiwibG9hZFN0b3JlUGx1Z2luIiwiXyIsImlzTmlsIiwiYXNzZXJ0Iiwic3RvcmFnZSIsIkxvY2FsRGF0YWJhc2VQbHVnaW4iLCJpbmZvIiwibmFtZSIsInBsdWdpbkNhdGVnb3J5IiwiU1RPUkFHRSIsIl90aGlzJGNvbmZpZzIiLCJfdGhpcyRjb25maWcyJHNlcnZlclMiLCJwbHVnaW5zIiwic3RvcmUiLCJnZXRQYWNrYWdlU3RvcmFnZSIsIndhcm4iLCJoZWFkIiwiYWRkUGFja2FnZSIsIm1ldGFkYXRhIiwiY2FsbGJhY2siLCJjaGVja1BhY2thZ2VMb2NhbCIsImNoZWNrUGFja2FnZVJlbW90ZSIsIl9pc0FsbG93UHVibGlzaE9mZmxpbmUiLCJfc3luY1VwbGlua3NNZXRhZGF0YSIsImJpbmQiLCJwdWJsaXNoUGFja2FnZSIsImVyciIsInB1Ymxpc2giLCJpc0Jvb2xlYW4iLCJhbGxvd19vZmZsaW5lIiwicmVhZFRva2VucyIsImZpbHRlciIsInNhdmVUb2tlbiIsInRva2VuIiwiZGVsZXRlVG9rZW4iLCJ1c2VyIiwidG9rZW5LZXkiLCJhZGRWZXJzaW9uIiwidmVyc2lvbiIsInRhZyIsIm1lcmdlVGFncyIsInRhZ0hhc2giLCJjaGFuZ2VQYWNrYWdlIiwicmV2aXNpb24iLCJyZW1vdmVQYWNrYWdlIiwiU2VhcmNoTWVtb3J5SW5kZXhlciIsInJlbW92ZSIsImNhdGNoIiwicmVhc29uIiwiZXJyb3IiLCJyZW1vdmVUYXJiYWxsIiwiZmlsZW5hbWUiLCJhZGRUYXJiYWxsIiwiaGFzTG9jYWxUYXJiYWxsIiwic2VsZiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwibG9jYWxTdHJlYW0iLCJnZXRUYXJiYWxsIiwiaXNPcGVuIiwib24iLCJzdGF0dXMiLCJIVFRQX1NUQVRVUyIsIk5PVF9GT1VORCIsImFib3J0IiwicmVhZFN0cmVhbSIsIlJlYWRUYXJiYWxsIiwiZW1pdCIsImVycjQwNCIsImdldFBhY2thZ2VNZXRhZGF0YSIsIl9kaXN0ZmlsZXMiLCJzZXJ2ZUZpbGUiLCJ2IiwicGlwZSIsImZpbGUiLCJ1cGxpbmsiLCJ1cGxpbmtJZCIsImhhc1Byb3h5VG8iLCJwYWNrYWdlcyIsIlByb3h5U3RvcmFnZSIsInVybCIsImNhY2hlIiwiX2F1dG9nZW5lcmF0ZWQiLCJzYXZlc3RyZWFtIiwib25fb3BlbiIsInJzdHJlYW0yIiwiZmV0Y2hUYXJiYWxsIiwiZG9uZSIsImZpbGVOYW1lIiwiZ2V0UGFja2FnZSIsIm9wdGlvbnMiLCJkYXRhIiwiSU5URVJOQUxfRVJST1IiLCJyZXEiLCJ1cGxpbmtzTG9vayIsImdldFBhY2thZ2VTeW5VcExpbmtzQ2FsbGJhY2siLCJyZXN1bHQiLCJ1cGxpbmtFcnJvcnMiLCJub3JtYWxpemVEaXN0VGFncyIsImNsZWFuVXBMaW5rc1JlZiIsImtlZXBVcExpbmtEYXRhIiwiX2F0dGFjaG1lbnRzIiwiYWJicmV2aWF0ZWQiLCJjb252ZXJ0QWJicmV2aWF0ZWRNYW5pZmVzdCIsInNlYXJjaCIsInN0YXJ0a2V5Iiwic2VhcmNoU3RyZWFtIiwiU3RyZWFtIiwiUGFzc1Rocm91Z2giLCJvYmplY3RNb2RlIiwiYXN5bmMiLCJlYWNoU2VyaWVzIiwia2V5cyIsInVwX25hbWUiLCJjYiIsIl9vcHRpb25zJHJlcSIsIl9vcHRpb25zJHJlcSRxdWVyeSIsInF1ZXJ5IiwibG9jYWwiLCJ1bmRlZmluZWQiLCJ1cGxpbmtTdHJlYW0iLCJlbmQiLCJsb2NhbFNlYXJjaFN0cmVhbSIsImdldExvY2FsRGF0YWJhc2UiLCJzdG9yYWdlUGx1Z2luIiwiZ2V0IiwibG9jYWxzIiwiaXRlbVBrZyIsInBrZ01ldGFkYXRhIiwibGF0ZXN0IiwiRElTVF9UQUdTIiwidmVyc2lvbnMiLCJ0aW1lTGlzdCIsInRpbWUiLCJ1c2VycyIsInB1c2giLCJwYWNrYWdlIiwicGFja2FnZUluZm8iLCJmb3VuZCIsInVwTGlua3MiLCJoYXNUb0xvb2tJbnRvVXBsaW5rcyIsImdlbmVyYXRlUGFja2FnZVRlbXBsYXRlIiwibWFwIiwidXBMaW5rIiwiX29wdGlvbnMiLCJhc3NpZ24iLCJ1cExpbmtNZXRhIiwiX3VwbGlua3MiLCJ1cG5hbWUiLCJpc09iamVjdCIsImZldGNoZWQiLCJEYXRlIiwibm93IiwibWF4YWdlIiwiZXRhZyIsImdldFJlbW90ZU1ldGFkYXRhIiwidXBMaW5rUmVzcG9uc2UiLCJlVGFnIiwicmVtb3RlU3RhdHVzIiwiRXJyb3JDb2RlIiwiZ2V0SW50ZXJuYWxFcnJvciIsInZhbGlkYXRpb25VdGlscyIsIm5vcm1hbGl6ZU1ldGFkYXRhIiwic3ViIiwibWVyZ2VVcGxpbmtUaW1lSW50b0xvY2FsIiwidXBkYXRlVmVyc2lvbnNIaWRkZW5VcExpbmsiLCJtZXJnZVZlcnNpb25zIiwidXBMaW5rc0Vycm9ycyIsIkFycmF5IiwiaXNBcnJheSIsInVwbGlua1RpbWVvdXRFcnJvciIsImoiLCJjb2RlIiwiZ2V0U2VydmljZVVuYXZhaWxhYmxlIiwiZ2V0Tm90Rm91bmQiLCJBUElfRVJST1IiLCJOT19QQUNLQUdFIiwidXBkYXRlVmVyc2lvbnMiLCJwYWNrYWdlSnNvbkxvY2FsIiwiZmlsdGVyRXJyb3JzIiwiY29uY2F0IiwiX3VwZGF0ZVZlcnNpb25zSGlkZGVuVXBMaW5rIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJmb3IiLCJfZGVmYXVsdCIsImV4cG9ydHMiXSwic291cmNlcyI6WyIuLi8uLi9zcmMvbGliL3N0b3JhZ2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IGFzeW5jLCB7IEFzeW5jUmVzdWx0QXJyYXlDYWxsYmFjayB9IGZyb20gJ2FzeW5jJztcbmltcG9ydCBidWlsZERlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgU3RyZWFtIGZyb20gJ3N0cmVhbSc7XG5cbmltcG9ydCB7IGhhc1Byb3h5VG8gfSBmcm9tICdAdmVyZGFjY2lvL2NvbmZpZyc7XG5pbXBvcnQgeyBQTFVHSU5fQ0FURUdPUlksIHBsdWdpblV0aWxzLCB2YWxpZGF0aW9uVXRpbHMgfSBmcm9tICdAdmVyZGFjY2lvL2NvcmUnO1xuaW1wb3J0IHsgYXN5bmNMb2FkUGx1Z2luIH0gZnJvbSAnQHZlcmRhY2Npby9sb2FkZXJzJztcbmltcG9ydCBMb2NhbERhdGFiYXNlUGx1Z2luIGZyb20gJ0B2ZXJkYWNjaW8vbG9jYWwtc3RvcmFnZS1sZWdhY3knO1xuaW1wb3J0IHsgU2VhcmNoTWVtb3J5SW5kZXhlciB9IGZyb20gJ0B2ZXJkYWNjaW8vc2VhcmNoLWluZGV4ZXInO1xuaW1wb3J0IHsgUmVhZFRhcmJhbGwgfSBmcm9tICdAdmVyZGFjY2lvL3N0cmVhbXMnO1xuaW1wb3J0IHtcbiAgQ2FsbGJhY2ssXG4gIENvbmZpZyxcbiAgRGlzdEZpbGUsXG4gIExvZ2dlcixcbiAgTWFuaWZlc3QsXG4gIE1lcmdlVGFncyxcbiAgUGFja2FnZSxcbiAgVmVyc2lvbixcbiAgVmVyc2lvbnMsXG59IGZyb20gJ0B2ZXJkYWNjaW8vdHlwZXMnO1xuaW1wb3J0IHsgR2VuZXJpY0JvZHksIFRva2VuLCBUb2tlbkZpbHRlciB9IGZyb20gJ0B2ZXJkYWNjaW8vdHlwZXMnO1xuXG5pbXBvcnQgeyBTdG9yYWdlUGx1Z2luTGVnYWN5IH0gZnJvbSAnLi4vLi4vdHlwZXMvY3VzdG9tJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL2xpYi9sb2dnZXInO1xuaW1wb3J0IHsgSVBsdWdpbkZpbHRlcnMsIElTeW5jVXBsaW5rcywgU3RyaW5nVmFsdWUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBBUElfRVJST1IsIERJU1RfVEFHUywgSFRUUF9TVEFUVVMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgTG9jYWxTdG9yYWdlLCB7IFN0b3JhZ2VQbHVnaW4gfSBmcm9tICcuL2xvY2FsLXN0b3JhZ2UnO1xuaW1wb3J0IHsgbWVyZ2VWZXJzaW9ucyB9IGZyb20gJy4vbWV0YWRhdGEtdXRpbHMnO1xuaW1wb3J0IHtcbiAgY2hlY2tQYWNrYWdlTG9jYWwsXG4gIGNoZWNrUGFja2FnZVJlbW90ZSxcbiAgY2xlYW5VcExpbmtzUmVmLFxuICBjb252ZXJ0QWJicmV2aWF0ZWRNYW5pZmVzdCxcbiAgZ2VuZXJhdGVQYWNrYWdlVGVtcGxhdGUsXG4gIG1lcmdlVXBsaW5rVGltZUludG9Mb2NhbCxcbiAgcHVibGlzaFBhY2thZ2UsXG59IGZyb20gJy4vc3RvcmFnZS11dGlscyc7XG5pbXBvcnQgUHJveHlTdG9yYWdlIGZyb20gJy4vdXAtc3RvcmFnZSc7XG5pbXBvcnQgeyBzZXR1cFVwTGlua3MsIHVwZGF0ZVZlcnNpb25zSGlkZGVuVXBMaW5rIH0gZnJvbSAnLi91cGxpbmstdXRpbCc7XG5pbXBvcnQgeyBFcnJvckNvZGUsIGlzT2JqZWN0LCBub3JtYWxpemVEaXN0VGFncyB9IGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBkZWJ1ZyA9IGJ1aWxkRGVidWcoJ3ZlcmRhY2NpbzpzdG9yYWdlJyk7XG5cbmNsYXNzIFN0b3JhZ2Uge1xuICBwdWJsaWMgbG9jYWxTdG9yYWdlOiBMb2NhbFN0b3JhZ2U7XG4gIHB1YmxpYyBjb25maWc6IENvbmZpZztcbiAgcHVibGljIGxvZ2dlcjogTG9nZ2VyO1xuICBwdWJsaWMgdXBsaW5rczogUmVjb3JkPHN0cmluZywgUHJveHlTdG9yYWdlPjtcbiAgcHVibGljIGZpbHRlcnM6IElQbHVnaW5GaWx0ZXJzO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcihjb25maWc6IENvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudXBsaW5rcyA9IHNldHVwVXBMaW5rcyhjb25maWcpO1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMuZmlsdGVycyA9IFtdO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmxvY2FsU3RvcmFnZSA9IG51bGw7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaW5pdChjb25maWc6IENvbmZpZywgZmlsdGVyczogSVBsdWdpbkZpbHRlcnMgPSBbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLmxvY2FsU3RvcmFnZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcbiAgICAgIGNvbnN0IHN0b3JhZ2VJbnN0YW5jZSA9IGF3YWl0IHRoaXMubG9hZFN0b3JhZ2UoY29uZmlnLCB0aGlzLmxvZ2dlcik7XG4gICAgICB0aGlzLmxvY2FsU3RvcmFnZSA9IG5ldyBMb2NhbFN0b3JhZ2UodGhpcy5jb25maWcsIGxvZ2dlciwgc3RvcmFnZUluc3RhbmNlKTtcbiAgICAgIGF3YWl0IHRoaXMubG9jYWxTdG9yYWdlLmdldFNlY3JldChjb25maWcpO1xuICAgICAgZGVidWcoJ2luaXRpYWxpemF0aW9uIGNvbXBsZXRlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Zygnc3RvcmFnZSBoYXMgYmVlbiBhbHJlYWR5IGluaXRpYWxpemVkJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmZpbHRlcnMpIHtcbiAgICAgIHRoaXMuZmlsdGVycyA9IGF3YWl0IGFzeW5jTG9hZFBsdWdpbjxwbHVnaW5VdGlscy5NYW5pZmVzdEZpbHRlcjx1bmtub3duPj4oXG4gICAgICAgIHRoaXMuY29uZmlnLmZpbHRlcnMsXG4gICAgICAgIHtcbiAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICAgIGxvZ2dlcjogdGhpcy5sb2dnZXIsXG4gICAgICAgIH0sXG4gICAgICAgIChwbHVnaW46IHBsdWdpblV0aWxzLk1hbmlmZXN0RmlsdGVyPENvbmZpZz4pID0+IHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHBsdWdpbi5maWx0ZXJfbWV0YWRhdGEgIT09ICd1bmRlZmluZWQnO1xuICAgICAgICB9LFxuICAgICAgICB0cnVlLFxuICAgICAgICB0aGlzLmNvbmZpZz8uc2VydmVyU2V0dGluZ3M/LnBsdWdpblByZWZpeCxcbiAgICAgICAgUExVR0lOX0NBVEVHT1JZLkZJTFRFUlxuICAgICAgKTtcbiAgICAgIGRlYnVnKCdmaWx0ZXJzIGF2YWlsYWJsZSAlbycsIHRoaXMuZmlsdGVycy5sZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbG9hZFN0b3JhZ2UoY29uZmlnOiBDb25maWcsIGxvZ2dlcjogTG9nZ2VyKTogUHJvbWlzZTxTdG9yYWdlUGx1Z2luPiB7XG4gICAgY29uc3QgU3RvcmFnZSA9IGF3YWl0IHRoaXMubG9hZFN0b3JlUGx1Z2luKCk7XG4gICAgaWYgKF8uaXNOaWwoU3RvcmFnZSkpIHtcbiAgICAgIGFzc2VydCh0aGlzLmNvbmZpZy5zdG9yYWdlLCAnQ09ORklHOiBzdG9yYWdlIHBhdGggbm90IGRlZmluZWQnKTtcbiAgICAgIGRlYnVnKCdubyBjdXN0b20gc3RvcmFnZSBmb3VuZCwgbG9hZGluZyBkZWZhdWx0IHN0b3JhZ2UgQHZlcmRhY2Npby9sb2NhbC1zdG9yYWdlJyk7XG4gICAgICBjb25zdCBsb2NhbFN0b3JhZ2UgPSBuZXcgTG9jYWxEYXRhYmFzZVBsdWdpbihjb25maWcsIGxvZ2dlcik7XG4gICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgeyBuYW1lOiAnQHZlcmRhY2Npby9sb2NhbC1zdG9yYWdlJywgcGx1Z2luQ2F0ZWdvcnk6IFBMVUdJTl9DQVRFR09SWS5TVE9SQUdFIH0sXG4gICAgICAgICdwbHVnaW4gQHtuYW1lfSBzdWNjZXNzZnVsbHkgbG9hZGVkIChAe3BsdWdpbkNhdGVnb3J5fSknXG4gICAgICApO1xuICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZTtcbiAgICB9XG4gICAgcmV0dXJuIFN0b3JhZ2UgYXMgU3RvcmFnZVBsdWdpbjtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbG9hZFN0b3JlUGx1Z2luKCk6IFByb21pc2U8U3RvcmFnZVBsdWdpbkxlZ2FjeTxDb25maWc+IHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgcGx1Z2luczogU3RvcmFnZVBsdWdpbkxlZ2FjeTxDb25maWc+W10gPSBhd2FpdCBhc3luY0xvYWRQbHVnaW48XG4gICAgICBwbHVnaW5VdGlscy5TdG9yYWdlPHVua25vd24+XG4gICAgPihcbiAgICAgIHRoaXMuY29uZmlnLnN0b3JlLFxuICAgICAge1xuICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICBsb2dnZXI6IHRoaXMubG9nZ2VyLFxuICAgICAgfSxcbiAgICAgIChwbHVnaW4pID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwbHVnaW4uZ2V0UGFja2FnZVN0b3JhZ2UgIT09ICd1bmRlZmluZWQnO1xuICAgICAgfSxcbiAgICAgIHRydWUsXG4gICAgICB0aGlzLmNvbmZpZz8uc2VydmVyU2V0dGluZ3M/LnBsdWdpblByZWZpeCxcbiAgICAgIFBMVUdJTl9DQVRFR09SWS5TVE9SQUdFXG4gICAgKTtcblxuICAgIGlmIChwbHVnaW5zLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oXG4gICAgICAgICdtb3JlIHRoYW4gb25lIHN0b3JhZ2UgcGx1Z2lucyBoYXMgYmVlbiBkZXRlY3RlZCwgbXVsdGlwbGUgc3RvcmFnZSBhcmUgbm90IHN1cHBvcnRlZCwgb25lIHdpbGwgYmUgc2VsZWN0ZWQgYXV0b21hdGljYWxseSdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF8uaGVhZChwbHVnaW5zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgQWRkIGEge25hbWV9IHBhY2thZ2UgdG8gYSBzeXN0ZW1cbiAgIEZ1bmN0aW9uIGNoZWNrcyBpZiBwYWNrYWdlIHdpdGggdGhlIHNhbWUgbmFtZSBpcyBhdmFpbGFibGUgZnJvbSB1cGxpbmtzLlxuICAgSWYgaXQgaXNuJ3QsIHdlIGNyZWF0ZSBwYWNrYWdlIGxvY2FsbHlcbiAgIFVzZWQgc3RvcmFnZXM6IGxvY2FsICh3cml0ZSkgJiYgdXBsaW5rc1xuICAgKi9cbiAgcHVibGljIGFzeW5jIGFkZFBhY2thZ2UobmFtZTogc3RyaW5nLCBtZXRhZGF0YTogYW55LCBjYWxsYmFjazogRnVuY3Rpb24pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY2hlY2tQYWNrYWdlTG9jYWwobmFtZSwgdGhpcy5sb2NhbFN0b3JhZ2UpO1xuICAgICAgYXdhaXQgY2hlY2tQYWNrYWdlUmVtb3RlKFxuICAgICAgICBuYW1lLFxuICAgICAgICB0aGlzLl9pc0FsbG93UHVibGlzaE9mZmxpbmUoKSxcbiAgICAgICAgdGhpcy5fc3luY1VwbGlua3NNZXRhZGF0YS5iaW5kKHRoaXMpXG4gICAgICApO1xuICAgICAgYXdhaXQgcHVibGlzaFBhY2thZ2UobmFtZSwgbWV0YWRhdGEsIHRoaXMubG9jYWxTdG9yYWdlKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfaXNBbGxvd1B1Ymxpc2hPZmZsaW5lKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgdGhpcy5jb25maWcucHVibGlzaCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIF8uaXNCb29sZWFuKHRoaXMuY29uZmlnLnB1Ymxpc2guYWxsb3dfb2ZmbGluZSkgJiZcbiAgICAgIHRoaXMuY29uZmlnLnB1Ymxpc2guYWxsb3dfb2ZmbGluZVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgcmVhZFRva2VucyhmaWx0ZXI6IFRva2VuRmlsdGVyKTogUHJvbWlzZTxUb2tlbltdPiB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxTdG9yYWdlLnJlYWRUb2tlbnMoZmlsdGVyKTtcbiAgfVxuXG4gIHB1YmxpYyBzYXZlVG9rZW4odG9rZW46IFRva2VuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxTdG9yYWdlLnNhdmVUb2tlbih0b2tlbik7XG4gIH1cblxuICBwdWJsaWMgZGVsZXRlVG9rZW4odXNlcjogc3RyaW5nLCB0b2tlbktleTogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbFN0b3JhZ2UuZGVsZXRlVG9rZW4odXNlciwgdG9rZW5LZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyB2ZXJzaW9uIG9mIHBhY2thZ2Uge25hbWV9IHRvIGEgc3lzdGVtXG4gICBVc2VkIHN0b3JhZ2VzOiBsb2NhbCAod3JpdGUpXG4gICAqL1xuICBwdWJsaWMgYWRkVmVyc2lvbihcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgdmVyc2lvbjogc3RyaW5nLFxuICAgIG1ldGFkYXRhOiBWZXJzaW9uLFxuICAgIHRhZzogU3RyaW5nVmFsdWUsXG4gICAgY2FsbGJhY2s6IENhbGxiYWNrXG4gICk6IHZvaWQge1xuICAgIHRoaXMubG9jYWxTdG9yYWdlLmFkZFZlcnNpb24obmFtZSwgdmVyc2lvbiwgbWV0YWRhdGEsIHRhZywgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFRhZ3MgYSBwYWNrYWdlIHZlcnNpb24gd2l0aCBhIHByb3ZpZGVkIHRhZ1xuICAgVXNlZCBzdG9yYWdlczogbG9jYWwgKHdyaXRlKVxuICAgKi9cbiAgcHVibGljIG1lcmdlVGFncyhuYW1lOiBzdHJpbmcsIHRhZ0hhc2g6IE1lcmdlVGFncywgY2FsbGJhY2s6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UubWVyZ2VUYWdzKG5hbWUsIHRhZ0hhc2gsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgYW4gZXhpc3RpbmcgcGFja2FnZSAoaS5lLiB1bnB1Ymxpc2ggb25lIHZlcnNpb24pXG4gICBGdW5jdGlvbiBjaGFuZ2VzIGEgcGFja2FnZSBpbmZvIGZyb20gbG9jYWwgc3RvcmFnZSBhbmQgYWxsIHVwbGlua3Mgd2l0aCB3cml0ZSBhY2Nlc3MuL1xuICAgVXNlZCBzdG9yYWdlczogbG9jYWwgKHdyaXRlKVxuICAgKi9cbiAgcHVibGljIGNoYW5nZVBhY2thZ2UoXG4gICAgbmFtZTogc3RyaW5nLFxuICAgIG1ldGFkYXRhOiBQYWNrYWdlLFxuICAgIHJldmlzaW9uOiBzdHJpbmcsXG4gICAgY2FsbGJhY2s6IENhbGxiYWNrXG4gICk6IHZvaWQge1xuICAgIHRoaXMubG9jYWxTdG9yYWdlLmNoYW5nZVBhY2thZ2UobmFtZSwgbWV0YWRhdGEsIHJldmlzaW9uLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgcGFja2FnZSBmcm9tIGEgc3lzdGVtXG4gICBGdW5jdGlvbiByZW1vdmVzIGEgcGFja2FnZSBmcm9tIGxvY2FsIHN0b3JhZ2VcbiAgIFVzZWQgc3RvcmFnZXM6IGxvY2FsICh3cml0ZSlcbiAgICovXG4gIHB1YmxpYyByZW1vdmVQYWNrYWdlKG5hbWU6IHN0cmluZywgY2FsbGJhY2s6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UucmVtb3ZlUGFja2FnZShuYW1lLCBjYWxsYmFjayk7XG4gICAgLy8gdXBkYXRlIHRoZSBpbmRleGVyXG4gICAgU2VhcmNoTWVtb3J5SW5kZXhlci5yZW1vdmUobmFtZSkuY2F0Y2goKHJlYXNvbikgPT4ge1xuICAgICAgbG9nZ2VyLmVycm9yKCdpbmRleGVyIGhhcyBmYWlsZWQgb24gcmVtb3ZlIGl0ZW0nKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgUmVtb3ZlIGEgdGFyYmFsbCBmcm9tIGEgc3lzdGVtXG4gICBGdW5jdGlvbiByZW1vdmVzIGEgdGFyYmFsbCBmcm9tIGxvY2FsIHN0b3JhZ2UuXG4gICBUYXJiYWxsIGluIHF1ZXN0aW9uIHNob3VsZCBub3QgYmUgbGlua2VkIHRvIGluIGFueSBleGlzdGluZ1xuICAgdmVyc2lvbnMsIGkuZS4gcGFja2FnZSB2ZXJzaW9uIHNob3VsZCBiZSB1bnB1Ymxpc2hlZCBmaXJzdC5cbiAgIFVzZWQgc3RvcmFnZTogbG9jYWwgKHdyaXRlKVxuICAgKi9cbiAgcHVibGljIHJlbW92ZVRhcmJhbGwobmFtZTogc3RyaW5nLCBmaWxlbmFtZTogc3RyaW5nLCByZXZpc2lvbjogc3RyaW5nLCBjYWxsYmFjazogQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0aGlzLmxvY2FsU3RvcmFnZS5yZW1vdmVUYXJiYWxsKG5hbWUsIGZpbGVuYW1lLCByZXZpc2lvbiwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwbG9hZCBhIHRhcmJhbGwgZm9yIHtuYW1lfSBwYWNrYWdlXG4gICBGdW5jdGlvbiBpcyBzeW5jaHJvbm91cyBhbmQgcmV0dXJucyBhIFdyaXRhYmxlU3RyZWFtXG4gICBVc2VkIHN0b3JhZ2VzOiBsb2NhbCAod3JpdGUpXG4gICAqL1xuICBwdWJsaWMgYWRkVGFyYmFsbChuYW1lOiBzdHJpbmcsIGZpbGVuYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbFN0b3JhZ2UuYWRkVGFyYmFsbChuYW1lLCBmaWxlbmFtZSk7XG4gIH1cblxuICBwdWJsaWMgaGFzTG9jYWxUYXJiYWxsKG5hbWU6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTxib29sZWFuPigocmVzb2x2ZSwgcmVqZWN0KTogdm9pZCA9PiB7XG4gICAgICBsZXQgbG9jYWxTdHJlYW06IGFueSA9IHNlbGYubG9jYWxTdG9yYWdlLmdldFRhcmJhbGwobmFtZSwgZmlsZW5hbWUpO1xuICAgICAgbGV0IGlzT3BlbiA9IGZhbHNlO1xuICAgICAgbG9jYWxTdHJlYW0ub24oJ2Vycm9yJywgKGVycik6IGFueSA9PiB7XG4gICAgICAgIGlmIChpc09wZW4gfHwgZXJyLnN0YXR1cyAhPT0gSFRUUF9TVEFUVVMuTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9jYWwgcmVwb3J0ZWQgNDA0IG9yIHJlcXVlc3Qgd2FzIGFib3J0ZWQgYWxyZWFkeVxuICAgICAgICBpZiAobG9jYWxTdHJlYW0pIHtcbiAgICAgICAgICBsb2NhbFN0cmVhbS5hYm9ydCgpO1xuICAgICAgICAgIGxvY2FsU3RyZWFtID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgIH0pO1xuICAgICAgbG9jYWxTdHJlYW0ub24oJ29wZW4nLCBmdW5jdGlvbiAoKTogdm9pZCB7XG4gICAgICAgIGlzT3BlbiA9IHRydWU7XG4gICAgICAgIGxvY2FsU3RyZWFtLmFib3J0KCk7XG4gICAgICAgIGxvY2FsU3RyZWFtID0gbnVsbDtcbiAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICBHZXQgYSB0YXJiYWxsIGZyb20gYSBzdG9yYWdlIGZvciB7bmFtZX0gcGFja2FnZVxuICAgRnVuY3Rpb24gaXMgc3luY2hyb25vdXMgYW5kIHJldHVybnMgYSBSZWFkYWJsZVN0cmVhbVxuICAgRnVuY3Rpb24gdHJpZXMgdG8gcmVhZCB0YXJiYWxsIGxvY2FsbHksIGlmIGl0IGZhaWxzIHRoZW4gaXQgcmVhZHMgcGFja2FnZVxuICAgaW5mb3JtYXRpb24gaW4gb3JkZXIgdG8gZmlndXJlIG91dCB3aGVyZSB3ZSBjYW4gZ2V0IHRoaXMgdGFyYmFsbCBmcm9tXG4gICBVc2VkIHN0b3JhZ2VzOiBsb2NhbCB8fCB1cGxpbmsgKGp1c3Qgb25lKVxuICAgKi9cbiAgcHVibGljIGdldFRhcmJhbGwobmFtZTogc3RyaW5nLCBmaWxlbmFtZTogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVhZFN0cmVhbSA9IG5ldyBSZWFkVGFyYmFsbCh7fSk7XG4gICAgcmVhZFN0cmVhbS5hYm9ydCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBpZiBzb21lb25lIHJlcXVlc3RpbmcgdGFyYmFsbCwgaXQgbWVhbnMgdGhhdCB3ZSBzaG91bGQgYWxyZWFkeSBoYXZlIHNvbWVcbiAgICAvLyBpbmZvcm1hdGlvbiBhYm91dCBpdCwgc28gZmV0Y2hpbmcgcGFja2FnZSBpbmZvIGlzIHVubmVjZXNzYXJ5XG5cbiAgICAvLyB0cnlpbmcgbG9jYWwgZmlyc3RcbiAgICAvLyBmbG93OiBzaG91bGQgYmUgSVJlYWRUYXJiYWxsXG4gICAgbGV0IGxvY2FsU3RyZWFtOiBhbnkgPSBzZWxmLmxvY2FsU3RvcmFnZS5nZXRUYXJiYWxsKG5hbWUsIGZpbGVuYW1lKTtcbiAgICBsZXQgaXNPcGVuID0gZmFsc2U7XG4gICAgbG9jYWxTdHJlYW0ub24oJ2Vycm9yJywgKGVycik6IGFueSA9PiB7XG4gICAgICBpZiAoaXNPcGVuIHx8IGVyci5zdGF0dXMgIT09IEhUVFBfU1RBVFVTLk5PVF9GT1VORCkge1xuICAgICAgICByZXR1cm4gcmVhZFN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICB9XG5cbiAgICAgIC8vIGxvY2FsIHJlcG9ydGVkIDQwNFxuICAgICAgY29uc3QgZXJyNDA0ID0gZXJyO1xuICAgICAgbG9jYWxTdHJlYW0uYWJvcnQoKTtcbiAgICAgIGxvY2FsU3RyZWFtID0gbnVsbDsgLy8gd2UgZm9yY2UgZm9yIGdhcmJhZ2UgY29sbGVjdG9yXG4gICAgICBzZWxmLmxvY2FsU3RvcmFnZS5nZXRQYWNrYWdlTWV0YWRhdGEobmFtZSwgKGVyciwgaW5mbzogUGFja2FnZSk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoXy5pc05pbChlcnIpICYmIGluZm8uX2Rpc3RmaWxlcyAmJiBfLmlzTmlsKGluZm8uX2Rpc3RmaWxlc1tmaWxlbmFtZV0pID09PSBmYWxzZSkge1xuICAgICAgICAgIC8vIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgZmlsZSBleGlzdHMgbG9jYWxseVxuICAgICAgICAgIHNlcnZlRmlsZShpbmZvLl9kaXN0ZmlsZXNbZmlsZW5hbWVdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB3ZSBrbm93IG5vdGhpbmcgYWJvdXQgdGhpcyBmaWxlLCB0cnlpbmcgdG8gZ2V0IGluZm9ybWF0aW9uIGVsc2V3aGVyZVxuICAgICAgICAgIHNlbGYuX3N5bmNVcGxpbmtzTWV0YWRhdGEobmFtZSwgaW5mbywge30sIChlcnIsIGluZm86IFBhY2thZ2UpOiBhbnkgPT4ge1xuICAgICAgICAgICAgaWYgKF8uaXNOaWwoZXJyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYWRTdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF8uaXNOaWwoaW5mby5fZGlzdGZpbGVzKSB8fCBfLmlzTmlsKGluZm8uX2Rpc3RmaWxlc1tmaWxlbmFtZV0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWFkU3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyNDA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcnZlRmlsZShpbmZvLl9kaXN0ZmlsZXNbZmlsZW5hbWVdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgbG9jYWxTdHJlYW0ub24oJ2NvbnRlbnQtbGVuZ3RoJywgZnVuY3Rpb24gKHYpOiB2b2lkIHtcbiAgICAgIHJlYWRTdHJlYW0uZW1pdCgnY29udGVudC1sZW5ndGgnLCB2KTtcbiAgICB9KTtcbiAgICBsb2NhbFN0cmVhbS5vbignb3BlbicsIGZ1bmN0aW9uICgpOiB2b2lkIHtcbiAgICAgIGlzT3BlbiA9IHRydWU7XG4gICAgICBsb2NhbFN0cmVhbS5waXBlKHJlYWRTdHJlYW0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZWFkU3RyZWFtO1xuXG4gICAgLyoqXG4gICAgICogRmV0Y2ggYW5kIGNhY2hlIGxvY2FsL3JlbW90ZSBwYWNrYWdlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZmlsZSBkZWZpbmUgdGhlIHBhY2thZ2Ugc2hhcGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXJ2ZUZpbGUoZmlsZTogRGlzdEZpbGUpOiB2b2lkIHtcbiAgICAgIGxldCB1cGxpbms6IGFueSA9IG51bGw7XG5cbiAgICAgIGZvciAoY29uc3QgdXBsaW5rSWQgaW4gc2VsZi51cGxpbmtzKSB7XG4gICAgICAgIGlmIChoYXNQcm94eVRvKG5hbWUsIHVwbGlua0lkLCBzZWxmLmNvbmZpZy5wYWNrYWdlcykpIHtcbiAgICAgICAgICB1cGxpbmsgPSBzZWxmLnVwbGlua3NbdXBsaW5rSWRdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh1cGxpbmsgPT0gbnVsbCkge1xuICAgICAgICB1cGxpbmsgPSBuZXcgUHJveHlTdG9yYWdlKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHVybDogZmlsZS51cmwsXG4gICAgICAgICAgICBjYWNoZTogdHJ1ZSxcbiAgICAgICAgICAgIF9hdXRvZ2VuZXJhdGVkOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2VsZi5jb25maWdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHNhdmVzdHJlYW06IGFueSA9IG51bGw7XG4gICAgICBpZiAodXBsaW5rLmNvbmZpZy5jYWNoZSkge1xuICAgICAgICBzYXZlc3RyZWFtID0gc2VsZi5sb2NhbFN0b3JhZ2UuYWRkVGFyYmFsbChuYW1lLCBmaWxlbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBvbl9vcGVuID0gZnVuY3Rpb24gKCk6IHZvaWQge1xuICAgICAgICAvLyBwcmV2ZW50IGl0IGZyb20gYmVpbmcgY2FsbGVkIHR3aWNlXG4gICAgICAgIG9uX29wZW4gPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgY29uc3QgcnN0cmVhbTIgPSB1cGxpbmsuZmV0Y2hUYXJiYWxsKGZpbGUudXJsKTtcbiAgICAgICAgcnN0cmVhbTIub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycik6IHZvaWQge1xuICAgICAgICAgIGlmIChzYXZlc3RyZWFtKSB7XG4gICAgICAgICAgICBzYXZlc3RyZWFtLmFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNhdmVzdHJlYW0gPSBudWxsO1xuICAgICAgICAgIHJlYWRTdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcnN0cmVhbTIub24oJ2VuZCcsIGZ1bmN0aW9uICgpOiB2b2lkIHtcbiAgICAgICAgICBpZiAoc2F2ZXN0cmVhbSkge1xuICAgICAgICAgICAgc2F2ZXN0cmVhbS5kb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByc3RyZWFtMi5vbignY29udGVudC1sZW5ndGgnLCBmdW5jdGlvbiAodik6IHZvaWQge1xuICAgICAgICAgIHJlYWRTdHJlYW0uZW1pdCgnY29udGVudC1sZW5ndGgnLCB2KTtcbiAgICAgICAgICBpZiAoc2F2ZXN0cmVhbSkge1xuICAgICAgICAgICAgc2F2ZXN0cmVhbS5lbWl0KCdjb250ZW50LWxlbmd0aCcsIHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJzdHJlYW0yLnBpcGUocmVhZFN0cmVhbSk7XG4gICAgICAgIGlmIChzYXZlc3RyZWFtKSB7XG4gICAgICAgICAgcnN0cmVhbTIucGlwZShzYXZlc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKHNhdmVzdHJlYW0pIHtcbiAgICAgICAgc2F2ZXN0cmVhbS5vbignb3BlbicsIGZ1bmN0aW9uICgpOiB2b2lkIHtcbiAgICAgICAgICBvbl9vcGVuKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNhdmVzdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycik6IHZvaWQge1xuICAgICAgICAgIHNlbGYubG9nZ2VyLndhcm4oXG4gICAgICAgICAgICB7IGVycjogZXJyLCBmaWxlTmFtZTogZmlsZSB9LFxuICAgICAgICAgICAgJ2Vycm9yIHNhdmluZyBmaWxlIEB7ZmlsZU5hbWV9OiBAe2Vyci5tZXNzYWdlfVxcbkB7ZXJyLnN0YWNrfSdcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChzYXZlc3RyZWFtKSB7XG4gICAgICAgICAgICBzYXZlc3RyZWFtLmFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNhdmVzdHJlYW0gPSBudWxsO1xuICAgICAgICAgIG9uX29wZW4oKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbl9vcGVuKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICBSZXRyaWV2ZSBhIHBhY2thZ2UgbWV0YWRhdGEgZm9yIHtuYW1lfSBwYWNrYWdlXG4gICBGdW5jdGlvbiBpbnZva2VzIGxvY2FsU3RvcmFnZS5nZXRQYWNrYWdlIGFuZCB1cGxpbmsuZ2V0X3BhY2thZ2UgZm9yIGV2ZXJ5XG4gICB1cGxpbmsgd2l0aCBwcm94eV9hY2Nlc3MgcmlnaHRzIGFnYWluc3Qge25hbWV9IGFuZCBjb21iaW5lcyByZXN1bHRzXG4gICBpbnRvIG9uZSBqc29uIG9iamVjdFxuICAgVXNlZCBzdG9yYWdlczogbG9jYWwgJiYgdXBsaW5rIChwcm94eV9hY2Nlc3MpXG5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IG9wdGlvbnMubmFtZSBQYWNrYWdlIE5hbWVcbiAgICogQHByb3BlcnR5IHtvYmplY3R9ICBvcHRpb25zLnJlcSBFeHByZXNzIGByZXFgIG9iamVjdFxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IG9wdGlvbnMua2VlcFVwTGlua0RhdGEga2VlcCB1cCBsaW5rIGluZm8gaW4gcGFja2FnZSBtZXRhLCBsYXN0IHVwZGF0ZSwgZXRjLlxuICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBvcHRpb25zLmNhbGxiYWNrIENhbGxiYWNrIGZvciByZWNlaXZlIGRhdGFcbiAgICovXG4gIHB1YmxpYyBnZXRQYWNrYWdlKG9wdGlvbnMpOiB2b2lkIHtcbiAgICB0aGlzLmxvY2FsU3RvcmFnZS5nZXRQYWNrYWdlTWV0YWRhdGEob3B0aW9ucy5uYW1lLCAoZXJyLCBkYXRhKTogdm9pZCA9PiB7XG4gICAgICBpZiAoZXJyICYmICghZXJyLnN0YXR1cyB8fCBlcnIuc3RhdHVzID49IEhUVFBfU1RBVFVTLklOVEVSTkFMX0VSUk9SKSkge1xuICAgICAgICAvLyByZXBvcnQgaW50ZXJuYWwgZXJyb3JzIHJpZ2h0IGF3YXlcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3luY1VwbGlua3NNZXRhZGF0YShcbiAgICAgICAgb3B0aW9ucy5uYW1lLFxuICAgICAgICBkYXRhLFxuICAgICAgICB7IHJlcTogb3B0aW9ucy5yZXEsIHVwbGlua3NMb29rOiBvcHRpb25zLnVwbGlua3NMb29rIH0sXG4gICAgICAgIGZ1bmN0aW9uIGdldFBhY2thZ2VTeW5VcExpbmtzQ2FsbGJhY2soZXJyLCByZXN1bHQ6IFBhY2thZ2UsIHVwbGlua0Vycm9ycyk6IHZvaWQge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhbGxiYWNrKGVycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9ybWFsaXplRGlzdFRhZ3MoY2xlYW5VcExpbmtzUmVmKG9wdGlvbnMua2VlcFVwTGlua0RhdGEsIHJlc3VsdCkpO1xuXG4gICAgICAgICAgLy8gbnBtIGNhbiB0aHJvdyBpZiB0aGlzIGZpZWxkIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICByZXN1bHQuX2F0dGFjaG1lbnRzID0ge307XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYWJicmV2aWF0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2sobnVsbCwgY29udmVydEFiYnJldmlhdGVkTWFuaWZlc3QocmVzdWx0KSwgdXBsaW5rRXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhudWxsLCByZXN1bHQsIHVwbGlua0Vycm9ycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICBSZXRyaWV2ZSByZW1vdGUgYW5kIGxvY2FsIHBhY2thZ2VzIG1vcmUgcmVjZW50IHRoYW4ge3N0YXJ0a2V5fVxuICAgRnVuY3Rpb24gc3RyZWFtcyBhbGwgcGFja2FnZXMgZnJvbSBhbGwgdXBsaW5rcyBmaXJzdCwgYW5kIHRoZW5cbiAgIGxvY2FsIHBhY2thZ2VzLlxuICAgTm90ZSB0aGF0IGxvY2FsIHBhY2thZ2VzIGNvdWxkIG92ZXJyaWRlIHJlZ2lzdHJ5IG9uZXMganVzdCBiZWNhdXNlXG4gICB0aGV5IGFwcGVhciBpbiBKU09OIGxhc3QuIFRoYXQncyBhIHRyYWRlLW9mZiB3ZSBtYWtlIHRvIGF2b2lkXG4gICBtZW1vcnkgaXNzdWVzLlxuICAgVXNlZCBzdG9yYWdlczogbG9jYWwgJiYgdXBsaW5rIChwcm94eV9hY2Nlc3MpXG4gICAqIEBwYXJhbSB7Kn0gc3RhcnRrZXlcbiAgICogQHBhcmFtIHsqfSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICovXG4gIHB1YmxpYyBzZWFyY2goc3RhcnRrZXk6IHN0cmluZywgb3B0aW9uczogYW55KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3Qgc2VhcmNoU3RyZWFtOiBhbnkgPSBuZXcgU3RyZWFtLlBhc3NUaHJvdWdoKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICBhc3luYy5lYWNoU2VyaWVzKFxuICAgICAgT2JqZWN0LmtleXModGhpcy51cGxpbmtzKSxcbiAgICAgIGZ1bmN0aW9uICh1cF9uYW1lLCBjYik6IHZvaWQge1xuICAgICAgICAvLyBzaG9ydGN1dDogaWYgYGxvY2FsPTFgIGlzIHN1cHBsaWVkLCBkb24ndCBjYWxsIHVwbGlua3NcbiAgICAgICAgaWYgKG9wdGlvbnMucmVxPy5xdWVyeT8ubG9jYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBjYigpO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5pbmZvKGBzZWFyY2ggZm9yIHVwbGluayAke3VwX25hbWV9YCk7XG4gICAgICAgIC8vIHNlYXJjaCBieSBrZXl3b3JkIGZvciBlYWNoIHVwbGlua1xuICAgICAgICBjb25zdCB1cGxpbmtTdHJlYW0gPSBzZWxmLnVwbGlua3NbdXBfbmFtZV0uc2VhcmNoKG9wdGlvbnMpO1xuICAgICAgICAvLyBqb2luIHVwbGluayBzdHJlYW0gd2l0aCBzdHJlYW1zIFBhc3NUaHJvdWdoXG4gICAgICAgIHVwbGlua1N0cmVhbS5waXBlKHNlYXJjaFN0cmVhbSwgeyBlbmQ6IGZhbHNlIH0pO1xuICAgICAgICB1cGxpbmtTdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycik6IHZvaWQge1xuICAgICAgICAgIHNlbGYubG9nZ2VyLmVycm9yKHsgZXJyOiBlcnIgfSwgJ3VwbGluayBlcnJvcjogQHtlcnIubWVzc2FnZX0nKTtcbiAgICAgICAgICBjYigpO1xuICAgICAgICAgIC8vIHRvIGF2b2lkIGNhbGwgY2FsbGJhY2sgbW9yZSB0aGFuIG9uY2VcbiAgICAgICAgICBjYiA9IGZ1bmN0aW9uICgpOiB2b2lkIHt9O1xuICAgICAgICB9KTtcbiAgICAgICAgdXBsaW5rU3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKTogdm9pZCB7XG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgICAvLyB0byBhdm9pZCBjYWxsIGNhbGxiYWNrIG1vcmUgdGhhbiBvbmNlXG4gICAgICAgICAgY2IgPSBmdW5jdGlvbiAoKTogdm9pZCB7fTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2VhcmNoU3RyZWFtLmFib3J0ID0gZnVuY3Rpb24gKCk6IHZvaWQge1xuICAgICAgICAgIGlmICh1cGxpbmtTdHJlYW0uYWJvcnQpIHtcbiAgICAgICAgICAgIHVwbGlua1N0cmVhbS5hYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYigpO1xuICAgICAgICAgIC8vIHRvIGF2b2lkIGNhbGwgY2FsbGJhY2sgbW9yZSB0aGFuIG9uY2VcbiAgICAgICAgICBjYiA9IGZ1bmN0aW9uICgpOiB2b2lkIHt9O1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIC8vIGV4ZWN1dGVkIGFmdGVyIGFsbCBzZXJpZXNcbiAgICAgIGZ1bmN0aW9uICgpOiB2b2lkIHtcbiAgICAgICAgLy8gYXR0YWNoIGEgbG9jYWwgc2VhcmNoIHJlc3VsdHNcbiAgICAgICAgY29uc3QgbG9jYWxTZWFyY2hTdHJlYW0gPSBzZWxmLmxvY2FsU3RvcmFnZS5zZWFyY2goc3RhcnRrZXksIG9wdGlvbnMpO1xuICAgICAgICBzZWFyY2hTdHJlYW0uYWJvcnQgPSBmdW5jdGlvbiAoKTogdm9pZCB7XG4gICAgICAgICAgbG9jYWxTZWFyY2hTdHJlYW0uYWJvcnQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbG9jYWxTZWFyY2hTdHJlYW0ucGlwZShzZWFyY2hTdHJlYW0sIHsgZW5kOiB0cnVlIH0pO1xuICAgICAgICBsb2NhbFNlYXJjaFN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgICBzZWxmLmxvZ2dlci5lcnJvcih7IGVycjogZXJyIH0sICdzZWFyY2ggZXJyb3I6IEB7ZXJyLm1lc3NhZ2V9Jyk7XG4gICAgICAgICAgc2VhcmNoU3RyZWFtLmVuZCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgcmV0dXJuIHNlYXJjaFN0cmVhbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBvbmx5IHByaXZhdGUgbG9jYWwgcGFja2FnZXNcbiAgICogQHBhcmFtIHsqfSBjYWxsYmFja1xuICAgKi9cbiAgcHVibGljIGdldExvY2FsRGF0YWJhc2UoY2FsbGJhY2s6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2Uuc3RvcmFnZVBsdWdpbi5nZXQoKGVyciwgbG9jYWxzKTogdm9pZCA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhY2thZ2VzOiBWZXJzaW9uW10gPSBbXTtcbiAgICAgIGNvbnN0IGdldFBhY2thZ2UgPSBmdW5jdGlvbiAoaXRlbVBrZyk6IHZvaWQge1xuICAgICAgICBzZWxmLmxvY2FsU3RvcmFnZS5nZXRQYWNrYWdlTWV0YWRhdGEoXG4gICAgICAgICAgbG9jYWxzW2l0ZW1Qa2ddLFxuICAgICAgICAgIGZ1bmN0aW9uIChlcnIsIHBrZ01ldGFkYXRhOiBQYWNrYWdlKTogdm9pZCB7XG4gICAgICAgICAgICBpZiAoXy5pc05pbChlcnIpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxhdGVzdCA9IHBrZ01ldGFkYXRhW0RJU1RfVEFHU10ubGF0ZXN0O1xuICAgICAgICAgICAgICBpZiAobGF0ZXN0ICYmIHBrZ01ldGFkYXRhLnZlcnNpb25zW2xhdGVzdF0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uOiBWZXJzaW9uID0gcGtnTWV0YWRhdGEudmVyc2lvbnNbbGF0ZXN0XTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lTGlzdCA9IHBrZ01ldGFkYXRhLnRpbWUgYXMgR2VuZXJpY0JvZHk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZSA9IHRpbWVMaXN0W2xhdGVzdF07XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHZlcnNpb24udGltZSA9IHRpbWU7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgZm9yIHN0YXJzIGFwaVxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB2ZXJzaW9uLnVzZXJzID0gcGtnTWV0YWRhdGEudXNlcnM7XG5cbiAgICAgICAgICAgICAgICBwYWNrYWdlcy5wdXNoKHZlcnNpb24pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYubG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgICAgICB7IHBhY2thZ2U6IGxvY2Fsc1tpdGVtUGtnXSB9LFxuICAgICAgICAgICAgICAgICAgJ3BhY2thZ2UgQHtwYWNrYWdlfSBkb2VzIG5vdCBoYXZlIGEgXCJsYXRlc3RcIiB0YWc/J1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGl0ZW1Qa2cgPj0gbG9jYWxzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcGFja2FnZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZ2V0UGFja2FnZShpdGVtUGtnICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgaWYgKGxvY2Fscy5sZW5ndGgpIHtcbiAgICAgICAgZ2V0UGFja2FnZSgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIFtdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiBmZXRjaGVzIHBhY2thZ2UgbWV0YWRhdGEgZnJvbSB1cGxpbmtzIGFuZCBzeW5jaHJvbml6ZXMgaXQgd2l0aCBsb2NhbCBkYXRhXG4gICBpZiBwYWNrYWdlIGlzIGF2YWlsYWJsZSBsb2NhbGx5LCBpdCBNVVNUIGJlIHByb3ZpZGVkIGluIHBrZ2luZm9cbiAgIHJldHVybnMgY2FsbGJhY2soZXJyLCByZXN1bHQsIHVwbGlua19lcnJvcnMpXG4gICAqL1xuICBwdWJsaWMgX3N5bmNVcGxpbmtzTWV0YWRhdGEoXG4gICAgbmFtZTogc3RyaW5nLFxuICAgIHBhY2thZ2VJbmZvOiBNYW5pZmVzdCxcbiAgICBvcHRpb25zOiBJU3luY1VwbGlua3MsXG4gICAgY2FsbGJhY2s6IENhbGxiYWNrXG4gICk6IHZvaWQge1xuICAgIGxldCBmb3VuZCA9IHRydWU7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgdXBMaW5rczogUHJveHlTdG9yYWdlW10gPSBbXTtcbiAgICBjb25zdCBoYXNUb0xvb2tJbnRvVXBsaW5rcyA9IF8uaXNOaWwob3B0aW9ucy51cGxpbmtzTG9vaykgfHwgb3B0aW9ucy51cGxpbmtzTG9vaztcblxuICAgIGlmICghcGFja2FnZUluZm8pIHtcbiAgICAgIGZvdW5kID0gZmFsc2U7XG4gICAgICBwYWNrYWdlSW5mbyA9IGdlbmVyYXRlUGFja2FnZVRlbXBsYXRlKG5hbWUpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgdXBsaW5rIGluIHRoaXMudXBsaW5rcykge1xuICAgICAgaWYgKGhhc1Byb3h5VG8obmFtZSwgdXBsaW5rLCB0aGlzLmNvbmZpZy5wYWNrYWdlcykgJiYgaGFzVG9Mb29rSW50b1VwbGlua3MpIHtcbiAgICAgICAgdXBMaW5rcy5wdXNoKHRoaXMudXBsaW5rc1t1cGxpbmtdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYy5tYXAoXG4gICAgICB1cExpbmtzLFxuICAgICAgKHVwTGluazogUHJveHlTdG9yYWdlLCBjYik6IHZvaWQgPT4ge1xuICAgICAgICBjb25zdCBfb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB1cExpbmtNZXRhID0gcGFja2FnZUluZm8uX3VwbGlua3NbdXBMaW5rLnVwbmFtZV07XG5cbiAgICAgICAgaWYgKGlzT2JqZWN0KHVwTGlua01ldGEpKSB7XG4gICAgICAgICAgY29uc3QgZmV0Y2hlZCA9IHVwTGlua01ldGEuZmV0Y2hlZDtcblxuICAgICAgICAgIGlmIChmZXRjaGVkICYmIERhdGUubm93KCkgLSBmZXRjaGVkIDwgdXBMaW5rLm1heGFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX29wdGlvbnMuZXRhZyA9IHVwTGlua01ldGEuZXRhZztcbiAgICAgICAgfVxuXG4gICAgICAgIHVwTGluay5nZXRSZW1vdGVNZXRhZGF0YShuYW1lLCBfb3B0aW9ucywgKGVyciwgdXBMaW5rUmVzcG9uc2UsIGVUYWcpOiB2b2lkID0+IHtcbiAgICAgICAgICBpZiAoZXJyICYmIGVyci5yZW1vdGVTdGF0dXMgPT09IDMwNCkge1xuICAgICAgICAgICAgdXBMaW5rTWV0YS5mZXRjaGVkID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZXJyIHx8ICF1cExpbmtSZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIFtlcnIgfHwgRXJyb3JDb2RlLmdldEludGVybmFsRXJyb3IoJ25vIGRhdGEnKV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1cExpbmtSZXNwb25zZSA9IHZhbGlkYXRpb25VdGlscy5ub3JtYWxpemVNZXRhZGF0YSh1cExpbmtSZXNwb25zZSwgbmFtZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBzZWxmLmxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN1YjogJ291dCcsXG4gICAgICAgICAgICAgICAgZXJyOiBlcnIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICdwYWNrYWdlLmpzb24gdmFsaWRhdGluZyBlcnJvciBAeyFlcnIubWVzc2FnZX1cXG5Ae2Vyci5zdGFja30nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIFtlcnJdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYWNrYWdlSW5mby5fdXBsaW5rc1t1cExpbmsudXBuYW1lXSA9IHtcbiAgICAgICAgICAgIGV0YWc6IGVUYWcsXG4gICAgICAgICAgICBmZXRjaGVkOiBEYXRlLm5vdygpLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBwYWNrYWdlSW5mbyA9IG1lcmdlVXBsaW5rVGltZUludG9Mb2NhbChwYWNrYWdlSW5mbywgdXBMaW5rUmVzcG9uc2UpO1xuXG4gICAgICAgICAgdXBkYXRlVmVyc2lvbnNIaWRkZW5VcExpbmsodXBMaW5rUmVzcG9uc2UudmVyc2lvbnMsIHVwTGluayk7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWVyZ2VWZXJzaW9ucyhwYWNrYWdlSW5mbywgdXBMaW5rUmVzcG9uc2UpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgc2VsZi5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdWI6ICdvdXQnLFxuICAgICAgICAgICAgICAgIGVycjogZXJyLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAncGFja2FnZS5qc29uIHBhcnNpbmcgZXJyb3IgQHshZXJyLm1lc3NhZ2V9XFxuQHtlcnIuc3RhY2t9J1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBbZXJyXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgd2UgZ290IHRvIHRoaXMgcG9pbnQsIGFzc3VtZSB0aGF0IHRoZSBjb3JyZWN0IHBhY2thZ2UgZXhpc3RzXG4gICAgICAgICAgLy8gb24gdGhlIHVwbGlua1xuICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICBjYigpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAoZXJyOiBFcnJvciwgdXBMaW5rc0Vycm9yczogYW55KTogQXN5bmNSZXN1bHRBcnJheUNhbGxiYWNrPHVua25vd24sIEVycm9yPiA9PiB7XG4gICAgICAgIGFzc2VydCghZXJyICYmIEFycmF5LmlzQXJyYXkodXBMaW5rc0Vycm9ycykpO1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBjb25uZWN0aW9uIHRpbWVvdXQgb3IgcmVzZXQgZXJyb3JzIHdpdGggdXBsaW5rKHMpXG4gICAgICAgIC8vICh0aGVzZSBzaG91bGQgYmUgaGFuZGxlZCBkaWZmZXJlbnRseSBmcm9tIHRoZSBwYWNrYWdlIG5vdCBiZWluZyBmb3VuZClcbiAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgIGxldCB1cGxpbmtUaW1lb3V0RXJyb3I7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cExpbmtzRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodXBMaW5rc0Vycm9yc1tpXSkge1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHVwTGlua3NFcnJvcnNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodXBMaW5rc0Vycm9yc1tpXVtqXSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IHVwTGlua3NFcnJvcnNbaV1bal0uY29kZTtcbiAgICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSAnRVRJTUVET1VUJyB8fCBjb2RlID09PSAnRVNPQ0tFVFRJTUVET1VUJyB8fCBjb2RlID09PSAnRUNPTk5SRVNFVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBsaW5rVGltZW91dEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHVwbGlua1RpbWVvdXRFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEVycm9yQ29kZS5nZXRTZXJ2aWNlVW5hdmFpbGFibGUoKSwgbnVsbCwgdXBMaW5rc0Vycm9ycyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhFcnJvckNvZGUuZ2V0Tm90Rm91bmQoQVBJX0VSUk9SLk5PX1BBQ0tBR0UpLCBudWxsLCB1cExpbmtzRXJyb3JzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1cExpbmtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBwYWNrYWdlSW5mbyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmxvY2FsU3RvcmFnZS51cGRhdGVWZXJzaW9ucyhcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHBhY2thZ2VJbmZvLFxuICAgICAgICAgIGFzeW5jIChlcnIsIHBhY2thZ2VKc29uTG9jYWw6IFBhY2thZ2UpOiBQcm9taXNlPGFueT4gPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFueSBlcnJvciBoZXJlIHdpbGwgY2F1c2UgYSA0MDQsIGxpa2UgYW4gdXBsaW5rIGVycm9yLiBUaGlzIGlzIGxpa2VseSB0aGUgcmlnaHQgdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIC8vIGFzIGEgYnJva2VuIGZpbHRlciBpcyBhIHNlY3VyaXR5IHJpc2suXG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJFcnJvcnM6IEVycm9yW10gPSBbXTtcbiAgICAgICAgICAgIC8vIFRoaXMgTVVTVCBiZSBkb25lIHNlcmlhbGx5IGFuZCBub3QgaW4gcGFyYWxsZWwgYXMgdGhleSBtb2RpZnkgcGFja2FnZUpzb25Mb2NhbFxuICAgICAgICAgICAgZm9yIChjb25zdCBmaWx0ZXIgb2Ygc2VsZi5maWx0ZXJzKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgZmlsdGVycyBjYW4gYXNzdW1lIGl0J3Mgc2F2ZSB0byBtb2RpZnkgcGFja2FnZUpzb25Mb2NhbCBhbmQgcmV0dXJuIGl0IGRpcmVjdGx5IGZvclxuICAgICAgICAgICAgICAgIC8vIHBlcmZvcm1hbmNlIChpLmUuIG5lZWQgbm90IGJlIHB1cmUpXG4gICAgICAgICAgICAgICAgcGFja2FnZUpzb25Mb2NhbCA9IGF3YWl0IGZpbHRlci5maWx0ZXJfbWV0YWRhdGEocGFja2FnZUpzb25Mb2NhbCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyRXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcGFja2FnZUpzb25Mb2NhbCwgXy5jb25jYXQodXBMaW5rc0Vycm9ycywgZmlsdGVyRXJyb3JzKSk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgaGlkZGVuIHZhbHVlIGZvciBlYWNoIHZlcnNpb24uXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZlcnNpb25zIGxpc3Qgb2YgdmVyc2lvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXBMaW5rIHVwbGluayBuYW1lXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwdWJsaWMgX3VwZGF0ZVZlcnNpb25zSGlkZGVuVXBMaW5rKHZlcnNpb25zOiBWZXJzaW9ucywgdXBMaW5rOiBQcm94eVN0b3JhZ2UpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdmVyc2lvbnMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmVyc2lvbnMsIGkpKSB7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSB2ZXJzaW9uc1tpXTtcblxuICAgICAgICAvLyBob2xkcyBhIFwiaGlkZGVuXCIgdmFsdWUgdG8gYmUgdXNlZCBieSB0aGUgcGFja2FnZSBzdG9yYWdlLlxuICAgICAgICB2ZXJzaW9uW1N5bWJvbC5mb3IoJ19fdmVyZGFjY2lvX3VwbGluaycpXSA9IHVwTGluay51cG5hbWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFN0b3JhZ2U7XG4iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLElBQUFBLE9BQUEsR0FBQUMsc0JBQUEsQ0FBQUMsT0FBQTtBQUNBLElBQUFDLE1BQUEsR0FBQUYsc0JBQUEsQ0FBQUMsT0FBQTtBQUNBLElBQUFFLE1BQUEsR0FBQUgsc0JBQUEsQ0FBQUMsT0FBQTtBQUNBLElBQUFHLE9BQUEsR0FBQUosc0JBQUEsQ0FBQUMsT0FBQTtBQUNBLElBQUFJLE9BQUEsR0FBQUwsc0JBQUEsQ0FBQUMsT0FBQTtBQUVBLElBQUFLLE9BQUEsR0FBQUwsT0FBQTtBQUNBLElBQUFNLEtBQUEsR0FBQU4sT0FBQTtBQUNBLElBQUFPLFFBQUEsR0FBQVAsT0FBQTtBQUNBLElBQUFRLG1CQUFBLEdBQUFULHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBUyxjQUFBLEdBQUFULE9BQUE7QUFDQSxJQUFBVSxRQUFBLEdBQUFWLE9BQUE7QUFlQSxJQUFBVyxPQUFBLEdBQUFYLE9BQUE7QUFFQSxJQUFBWSxVQUFBLEdBQUFaLE9BQUE7QUFDQSxJQUFBYSxhQUFBLEdBQUFkLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBYyxjQUFBLEdBQUFkLE9BQUE7QUFDQSxJQUFBZSxhQUFBLEdBQUFmLE9BQUE7QUFTQSxJQUFBZ0IsVUFBQSxHQUFBakIsc0JBQUEsQ0FBQUMsT0FBQTtBQUNBLElBQUFpQixXQUFBLEdBQUFqQixPQUFBO0FBQ0EsSUFBQWtCLE1BQUEsR0FBQWxCLE9BQUE7QUFBaUUsU0FBQUQsdUJBQUFvQixDQUFBLFdBQUFBLENBQUEsSUFBQUEsQ0FBQSxDQUFBQyxVQUFBLEdBQUFELENBQUEsS0FBQUUsT0FBQSxFQUFBRixDQUFBO0FBQUEsU0FBQUcsZ0JBQUFILENBQUEsRUFBQUksQ0FBQSxFQUFBQyxDQUFBLFlBQUFELENBQUEsR0FBQUUsY0FBQSxDQUFBRixDQUFBLE1BQUFKLENBQUEsR0FBQU8sTUFBQSxDQUFBQyxjQUFBLENBQUFSLENBQUEsRUFBQUksQ0FBQSxJQUFBSyxLQUFBLEVBQUFKLENBQUEsRUFBQUssVUFBQSxNQUFBQyxZQUFBLE1BQUFDLFFBQUEsVUFBQVosQ0FBQSxDQUFBSSxDQUFBLElBQUFDLENBQUEsRUFBQUwsQ0FBQTtBQUFBLFNBQUFNLGVBQUFELENBQUEsUUFBQVEsQ0FBQSxHQUFBQyxZQUFBLENBQUFULENBQUEsdUNBQUFRLENBQUEsR0FBQUEsQ0FBQSxHQUFBQSxDQUFBO0FBQUEsU0FBQUMsYUFBQVQsQ0FBQSxFQUFBRCxDQUFBLDJCQUFBQyxDQUFBLEtBQUFBLENBQUEsU0FBQUEsQ0FBQSxNQUFBTCxDQUFBLEdBQUFLLENBQUEsQ0FBQVUsTUFBQSxDQUFBQyxXQUFBLGtCQUFBaEIsQ0FBQSxRQUFBYSxDQUFBLEdBQUFiLENBQUEsQ0FBQWlCLElBQUEsQ0FBQVosQ0FBQSxFQUFBRCxDQUFBLHVDQUFBUyxDQUFBLFNBQUFBLENBQUEsWUFBQUssU0FBQSx5RUFBQWQsQ0FBQSxHQUFBZSxNQUFBLEdBQUFDLE1BQUEsRUFBQWYsQ0FBQTtBQUVqRSxNQUFNZ0IsS0FBSyxHQUFHLElBQUFDLGNBQVUsRUFBQyxtQkFBbUIsQ0FBQztBQUU3QyxNQUFNQyxPQUFPLENBQUM7RUFPTEMsV0FBV0EsQ0FBQ0MsTUFBYyxFQUFFO0lBQUF0QixlQUFBO0lBQUFBLGVBQUE7SUFBQUEsZUFBQTtJQUFBQSxlQUFBO0lBQUFBLGVBQUE7SUFDakMsSUFBSSxDQUFDc0IsTUFBTSxHQUFHQSxNQUFNO0lBQ3BCLElBQUksQ0FBQ0MsT0FBTyxHQUFHLElBQUFDLHdCQUFZLEVBQUNGLE1BQU0sQ0FBQztJQUNuQyxJQUFJLENBQUNHLE1BQU0sR0FBR0EsY0FBTTtJQUNwQixJQUFJLENBQUNDLE9BQU8sR0FBRyxFQUFFO0lBQ2pCO0lBQ0EsSUFBSSxDQUFDQyxZQUFZLEdBQUcsSUFBSTtFQUMxQjtFQUVBLE1BQWFDLElBQUlBLENBQUNOLE1BQWMsRUFBRUksT0FBdUIsR0FBRyxFQUFFLEVBQWlCO0lBQzdFLElBQUksSUFBSSxDQUFDQyxZQUFZLEtBQUssSUFBSSxFQUFFO01BQzlCLElBQUksQ0FBQ0QsT0FBTyxHQUFHQSxPQUFPO01BQ3RCLE1BQU1HLGVBQWUsR0FBRyxNQUFNLElBQUksQ0FBQ0MsV0FBVyxDQUFDUixNQUFNLEVBQUUsSUFBSSxDQUFDRyxNQUFNLENBQUM7TUFDbkUsSUFBSSxDQUFDRSxZQUFZLEdBQUcsSUFBSUkscUJBQVksQ0FBQyxJQUFJLENBQUNULE1BQU0sRUFBRUcsY0FBTSxFQUFFSSxlQUFlLENBQUM7TUFDMUUsTUFBTSxJQUFJLENBQUNGLFlBQVksQ0FBQ0ssU0FBUyxDQUFDVixNQUFNLENBQUM7TUFDekNKLEtBQUssQ0FBQywwQkFBMEIsQ0FBQztJQUNuQyxDQUFDLE1BQU07TUFDTEEsS0FBSyxDQUFDLHNDQUFzQyxDQUFDO0lBQy9DO0lBRUEsSUFBSSxDQUFDLElBQUksQ0FBQ1EsT0FBTyxFQUFFO01BQUEsSUFBQU8sWUFBQSxFQUFBQyxxQkFBQTtNQUNqQixJQUFJLENBQUNSLE9BQU8sR0FBRyxNQUFNLElBQUFTLHdCQUFlLEVBQ2xDLElBQUksQ0FBQ2IsTUFBTSxDQUFDSSxPQUFPLEVBQ25CO1FBQ0VKLE1BQU0sRUFBRSxJQUFJLENBQUNBLE1BQU07UUFDbkJHLE1BQU0sRUFBRSxJQUFJLENBQUNBO01BQ2YsQ0FBQyxFQUNBVyxNQUEwQyxJQUFLO1FBQzlDLE9BQU8sT0FBT0EsTUFBTSxDQUFDQyxlQUFlLEtBQUssV0FBVztNQUN0RCxDQUFDLEVBQ0QsSUFBSSxHQUFBSixZQUFBLEdBQ0osSUFBSSxDQUFDWCxNQUFNLGNBQUFXLFlBQUEsd0JBQUFDLHFCQUFBLEdBQVhELFlBQUEsQ0FBYUssY0FBYyxjQUFBSixxQkFBQSx1QkFBM0JBLHFCQUFBLENBQTZCSyxZQUFZLEVBQ3pDQyxxQkFBZSxDQUFDQyxNQUNsQixDQUFDO01BQ0R2QixLQUFLLENBQUMsc0JBQXNCLEVBQUUsSUFBSSxDQUFDUSxPQUFPLENBQUNnQixNQUFNLENBQUM7SUFDcEQ7RUFDRjtFQUVBLE1BQWNaLFdBQVdBLENBQUNSLE1BQWMsRUFBRUcsTUFBYyxFQUEwQjtJQUNoRixNQUFNTCxPQUFPLEdBQUcsTUFBTSxJQUFJLENBQUN1QixlQUFlLENBQUMsQ0FBQztJQUM1QyxJQUFJQyxlQUFDLENBQUNDLEtBQUssQ0FBQ3pCLE9BQU8sQ0FBQyxFQUFFO01BQ3BCLElBQUEwQixlQUFNLEVBQUMsSUFBSSxDQUFDeEIsTUFBTSxDQUFDeUIsT0FBTyxFQUFFLGtDQUFrQyxDQUFDO01BQy9EN0IsS0FBSyxDQUFDLDJFQUEyRSxDQUFDO01BQ2xGLE1BQU1TLFlBQVksR0FBRyxJQUFJcUIsMkJBQW1CLENBQUMxQixNQUFNLEVBQUVHLE1BQU0sQ0FBQztNQUM1REEsTUFBTSxDQUFDd0IsSUFBSSxDQUNUO1FBQUVDLElBQUksRUFBRSwwQkFBMEI7UUFBRUMsY0FBYyxFQUFFWCxxQkFBZSxDQUFDWTtNQUFRLENBQUMsRUFDN0Usd0RBQ0YsQ0FBQztNQUNELE9BQU96QixZQUFZO0lBQ3JCO0lBQ0EsT0FBT1AsT0FBTztFQUNoQjtFQUVBLE1BQWN1QixlQUFlQSxDQUFBLEVBQXFEO0lBQUEsSUFBQVUsYUFBQSxFQUFBQyxxQkFBQTtJQUNoRixNQUFNQyxPQUFzQyxHQUFHLE1BQU0sSUFBQXBCLHdCQUFlLEVBR2xFLElBQUksQ0FBQ2IsTUFBTSxDQUFDa0MsS0FBSyxFQUNqQjtNQUNFbEMsTUFBTSxFQUFFLElBQUksQ0FBQ0EsTUFBTTtNQUNuQkcsTUFBTSxFQUFFLElBQUksQ0FBQ0E7SUFDZixDQUFDLEVBQ0FXLE1BQU0sSUFBSztNQUNWLE9BQU8sT0FBT0EsTUFBTSxDQUFDcUIsaUJBQWlCLEtBQUssV0FBVztJQUN4RCxDQUFDLEVBQ0QsSUFBSSxHQUFBSixhQUFBLEdBQ0osSUFBSSxDQUFDL0IsTUFBTSxjQUFBK0IsYUFBQSx3QkFBQUMscUJBQUEsR0FBWEQsYUFBQSxDQUFhZixjQUFjLGNBQUFnQixxQkFBQSx1QkFBM0JBLHFCQUFBLENBQTZCZixZQUFZLEVBQ3pDQyxxQkFBZSxDQUFDWSxPQUNsQixDQUFDO0lBRUQsSUFBSUcsT0FBTyxDQUFDYixNQUFNLEdBQUcsQ0FBQyxFQUFFO01BQ3RCLElBQUksQ0FBQ2pCLE1BQU0sQ0FBQ2lDLElBQUksQ0FDZCx5SEFDRixDQUFDO0lBQ0g7SUFFQSxPQUFPZCxlQUFDLENBQUNlLElBQUksQ0FBQ0osT0FBTyxDQUFDO0VBQ3hCOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFLE1BQWFLLFVBQVVBLENBQUNWLElBQVksRUFBRVcsUUFBYSxFQUFFQyxRQUFrQixFQUFpQjtJQUN0RixJQUFJO01BQ0YsTUFBTSxJQUFBQywrQkFBaUIsRUFBQ2IsSUFBSSxFQUFFLElBQUksQ0FBQ3ZCLFlBQVksQ0FBQztNQUNoRCxNQUFNLElBQUFxQyxnQ0FBa0IsRUFDdEJkLElBQUksRUFDSixJQUFJLENBQUNlLHNCQUFzQixDQUFDLENBQUMsRUFDN0IsSUFBSSxDQUFDQyxvQkFBb0IsQ0FBQ0MsSUFBSSxDQUFDLElBQUksQ0FDckMsQ0FBQztNQUNELE1BQU0sSUFBQUMsNEJBQWMsRUFBQ2xCLElBQUksRUFBRVcsUUFBUSxFQUFFLElBQUksQ0FBQ2xDLFlBQVksQ0FBQztNQUN2RG1DLFFBQVEsQ0FBQyxDQUFDO0lBQ1osQ0FBQyxDQUFDLE9BQU9PLEdBQVEsRUFBRTtNQUNqQlAsUUFBUSxDQUFDTyxHQUFHLENBQUM7SUFDZjtFQUNGO0VBRVFKLHNCQUFzQkEsQ0FBQSxFQUFZO0lBQ3hDLE9BQ0UsT0FBTyxJQUFJLENBQUMzQyxNQUFNLENBQUNnRCxPQUFPLEtBQUssV0FBVyxJQUMxQzFCLGVBQUMsQ0FBQzJCLFNBQVMsQ0FBQyxJQUFJLENBQUNqRCxNQUFNLENBQUNnRCxPQUFPLENBQUNFLGFBQWEsQ0FBQyxJQUM5QyxJQUFJLENBQUNsRCxNQUFNLENBQUNnRCxPQUFPLENBQUNFLGFBQWE7RUFFckM7RUFFT0MsVUFBVUEsQ0FBQ0MsTUFBbUIsRUFBb0I7SUFDdkQsT0FBTyxJQUFJLENBQUMvQyxZQUFZLENBQUM4QyxVQUFVLENBQUNDLE1BQU0sQ0FBQztFQUM3QztFQUVPQyxTQUFTQSxDQUFDQyxLQUFZLEVBQWlCO0lBQzVDLE9BQU8sSUFBSSxDQUFDakQsWUFBWSxDQUFDZ0QsU0FBUyxDQUFDQyxLQUFLLENBQUM7RUFDM0M7RUFFT0MsV0FBV0EsQ0FBQ0MsSUFBWSxFQUFFQyxRQUFnQixFQUFnQjtJQUMvRCxPQUFPLElBQUksQ0FBQ3BELFlBQVksQ0FBQ2tELFdBQVcsQ0FBQ0MsSUFBSSxFQUFFQyxRQUFRLENBQUM7RUFDdEQ7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDU0MsVUFBVUEsQ0FDZjlCLElBQVksRUFDWitCLE9BQWUsRUFDZnBCLFFBQWlCLEVBQ2pCcUIsR0FBZ0IsRUFDaEJwQixRQUFrQixFQUNaO0lBQ04sSUFBSSxDQUFDbkMsWUFBWSxDQUFDcUQsVUFBVSxDQUFDOUIsSUFBSSxFQUFFK0IsT0FBTyxFQUFFcEIsUUFBUSxFQUFFcUIsR0FBRyxFQUFFcEIsUUFBUSxDQUFDO0VBQ3RFOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0VBQ1NxQixTQUFTQSxDQUFDakMsSUFBWSxFQUFFa0MsT0FBa0IsRUFBRXRCLFFBQWtCLEVBQVE7SUFDM0UsSUFBSSxDQUFDbkMsWUFBWSxDQUFDd0QsU0FBUyxDQUFDakMsSUFBSSxFQUFFa0MsT0FBTyxFQUFFdEIsUUFBUSxDQUFDO0VBQ3REOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFDU3VCLGFBQWFBLENBQ2xCbkMsSUFBWSxFQUNaVyxRQUFpQixFQUNqQnlCLFFBQWdCLEVBQ2hCeEIsUUFBa0IsRUFDWjtJQUNOLElBQUksQ0FBQ25DLFlBQVksQ0FBQzBELGFBQWEsQ0FBQ25DLElBQUksRUFBRVcsUUFBUSxFQUFFeUIsUUFBUSxFQUFFeEIsUUFBUSxDQUFDO0VBQ3JFOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFDU3lCLGFBQWFBLENBQUNyQyxJQUFZLEVBQUVZLFFBQWtCLEVBQVE7SUFDM0QsSUFBSSxDQUFDbkMsWUFBWSxDQUFDNEQsYUFBYSxDQUFDckMsSUFBSSxFQUFFWSxRQUFRLENBQUM7SUFDL0M7SUFDQTBCLGtDQUFtQixDQUFDQyxNQUFNLENBQUN2QyxJQUFJLENBQUMsQ0FBQ3dDLEtBQUssQ0FBRUMsTUFBTSxJQUFLO01BQ2pEbEUsY0FBTSxDQUFDbUUsS0FBSyxDQUFDLG1DQUFtQyxDQUFDO0lBQ25ELENBQUMsQ0FBQztFQUNKOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ1NDLGFBQWFBLENBQUMzQyxJQUFZLEVBQUU0QyxRQUFnQixFQUFFUixRQUFnQixFQUFFeEIsUUFBa0IsRUFBUTtJQUMvRixJQUFJLENBQUNuQyxZQUFZLENBQUNrRSxhQUFhLENBQUMzQyxJQUFJLEVBQUU0QyxRQUFRLEVBQUVSLFFBQVEsRUFBRXhCLFFBQVEsQ0FBQztFQUNyRTs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBQ1NpQyxVQUFVQSxDQUFDN0MsSUFBWSxFQUFFNEMsUUFBZ0IsRUFBRTtJQUNoRCxPQUFPLElBQUksQ0FBQ25FLFlBQVksQ0FBQ29FLFVBQVUsQ0FBQzdDLElBQUksRUFBRTRDLFFBQVEsQ0FBQztFQUNyRDtFQUVPRSxlQUFlQSxDQUFDOUMsSUFBWSxFQUFFNEMsUUFBZ0IsRUFBb0I7SUFDdkUsTUFBTUcsSUFBSSxHQUFHLElBQUk7SUFDakIsT0FBTyxJQUFJQyxPQUFPLENBQVUsQ0FBQ0MsT0FBTyxFQUFFQyxNQUFNLEtBQVc7TUFDckQsSUFBSUMsV0FBZ0IsR0FBR0osSUFBSSxDQUFDdEUsWUFBWSxDQUFDMkUsVUFBVSxDQUFDcEQsSUFBSSxFQUFFNEMsUUFBUSxDQUFDO01BQ25FLElBQUlTLE1BQU0sR0FBRyxLQUFLO01BQ2xCRixXQUFXLENBQUNHLEVBQUUsQ0FBQyxPQUFPLEVBQUduQyxHQUFHLElBQVU7UUFDcEMsSUFBSWtDLE1BQU0sSUFBSWxDLEdBQUcsQ0FBQ29DLE1BQU0sS0FBS0Msc0JBQVcsQ0FBQ0MsU0FBUyxFQUFFO1VBQ2xEUCxNQUFNLENBQUMvQixHQUFHLENBQUM7UUFDYjtRQUNBO1FBQ0EsSUFBSWdDLFdBQVcsRUFBRTtVQUNmQSxXQUFXLENBQUNPLEtBQUssQ0FBQyxDQUFDO1VBQ25CUCxXQUFXLEdBQUcsSUFBSTtRQUNwQjtRQUNBRixPQUFPLENBQUMsS0FBSyxDQUFDO01BQ2hCLENBQUMsQ0FBQztNQUNGRSxXQUFXLENBQUNHLEVBQUUsQ0FBQyxNQUFNLEVBQUUsWUFBa0I7UUFDdkNELE1BQU0sR0FBRyxJQUFJO1FBQ2JGLFdBQVcsQ0FBQ08sS0FBSyxDQUFDLENBQUM7UUFDbkJQLFdBQVcsR0FBRyxJQUFJO1FBQ2xCRixPQUFPLENBQUMsSUFBSSxDQUFDO01BQ2YsQ0FBQyxDQUFDO0lBQ0osQ0FBQyxDQUFDO0VBQ0o7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDU0csVUFBVUEsQ0FBQ3BELElBQVksRUFBRTRDLFFBQWdCLEVBQUU7SUFDaEQsTUFBTWUsVUFBVSxHQUFHLElBQUlDLG9CQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdENELFVBQVUsQ0FBQ0QsS0FBSyxHQUFHLFlBQVksQ0FBQyxDQUFDO0lBRWpDLE1BQU1YLElBQUksR0FBRyxJQUFJOztJQUVqQjtJQUNBOztJQUVBO0lBQ0E7SUFDQSxJQUFJSSxXQUFnQixHQUFHSixJQUFJLENBQUN0RSxZQUFZLENBQUMyRSxVQUFVLENBQUNwRCxJQUFJLEVBQUU0QyxRQUFRLENBQUM7SUFDbkUsSUFBSVMsTUFBTSxHQUFHLEtBQUs7SUFDbEJGLFdBQVcsQ0FBQ0csRUFBRSxDQUFDLE9BQU8sRUFBR25DLEdBQUcsSUFBVTtNQUNwQyxJQUFJa0MsTUFBTSxJQUFJbEMsR0FBRyxDQUFDb0MsTUFBTSxLQUFLQyxzQkFBVyxDQUFDQyxTQUFTLEVBQUU7UUFDbEQsT0FBT0UsVUFBVSxDQUFDRSxJQUFJLENBQUMsT0FBTyxFQUFFMUMsR0FBRyxDQUFDO01BQ3RDOztNQUVBO01BQ0EsTUFBTTJDLE1BQU0sR0FBRzNDLEdBQUc7TUFDbEJnQyxXQUFXLENBQUNPLEtBQUssQ0FBQyxDQUFDO01BQ25CUCxXQUFXLEdBQUcsSUFBSSxDQUFDLENBQUM7TUFDcEJKLElBQUksQ0FBQ3RFLFlBQVksQ0FBQ3NGLGtCQUFrQixDQUFDL0QsSUFBSSxFQUFFLENBQUNtQixHQUFHLEVBQUVwQixJQUFhLEtBQVc7UUFDdkUsSUFBSUwsZUFBQyxDQUFDQyxLQUFLLENBQUN3QixHQUFHLENBQUMsSUFBSXBCLElBQUksQ0FBQ2lFLFVBQVUsSUFBSXRFLGVBQUMsQ0FBQ0MsS0FBSyxDQUFDSSxJQUFJLENBQUNpRSxVQUFVLENBQUNwQixRQUFRLENBQUMsQ0FBQyxLQUFLLEtBQUssRUFBRTtVQUNuRjtVQUNBcUIsU0FBUyxDQUFDbEUsSUFBSSxDQUFDaUUsVUFBVSxDQUFDcEIsUUFBUSxDQUFDLENBQUM7UUFDdEMsQ0FBQyxNQUFNO1VBQ0w7VUFDQUcsSUFBSSxDQUFDL0Isb0JBQW9CLENBQUNoQixJQUFJLEVBQUVELElBQUksRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDb0IsR0FBRyxFQUFFcEIsSUFBYSxLQUFVO1lBQ3JFLElBQUlMLGVBQUMsQ0FBQ0MsS0FBSyxDQUFDd0IsR0FBRyxDQUFDLEtBQUssS0FBSyxFQUFFO2NBQzFCLE9BQU93QyxVQUFVLENBQUNFLElBQUksQ0FBQyxPQUFPLEVBQUUxQyxHQUFHLENBQUM7WUFDdEM7WUFDQSxJQUFJekIsZUFBQyxDQUFDQyxLQUFLLENBQUNJLElBQUksQ0FBQ2lFLFVBQVUsQ0FBQyxJQUFJdEUsZUFBQyxDQUFDQyxLQUFLLENBQUNJLElBQUksQ0FBQ2lFLFVBQVUsQ0FBQ3BCLFFBQVEsQ0FBQyxDQUFDLEVBQUU7Y0FDbEUsT0FBT2UsVUFBVSxDQUFDRSxJQUFJLENBQUMsT0FBTyxFQUFFQyxNQUFNLENBQUM7WUFDekM7WUFDQUcsU0FBUyxDQUFDbEUsSUFBSSxDQUFDaUUsVUFBVSxDQUFDcEIsUUFBUSxDQUFDLENBQUM7VUFDdEMsQ0FBQyxDQUFDO1FBQ0o7TUFDRixDQUFDLENBQUM7SUFDSixDQUFDLENBQUM7SUFDRk8sV0FBVyxDQUFDRyxFQUFFLENBQUMsZ0JBQWdCLEVBQUUsVUFBVVksQ0FBQyxFQUFRO01BQ2xEUCxVQUFVLENBQUNFLElBQUksQ0FBQyxnQkFBZ0IsRUFBRUssQ0FBQyxDQUFDO0lBQ3RDLENBQUMsQ0FBQztJQUNGZixXQUFXLENBQUNHLEVBQUUsQ0FBQyxNQUFNLEVBQUUsWUFBa0I7TUFDdkNELE1BQU0sR0FBRyxJQUFJO01BQ2JGLFdBQVcsQ0FBQ2dCLElBQUksQ0FBQ1IsVUFBVSxDQUFDO0lBQzlCLENBQUMsQ0FBQztJQUNGLE9BQU9BLFVBQVU7O0lBRWpCO0FBQ0o7QUFDQTtBQUNBO0lBQ0ksU0FBU00sU0FBU0EsQ0FBQ0csSUFBYyxFQUFRO01BQ3ZDLElBQUlDLE1BQVcsR0FBRyxJQUFJO01BRXRCLEtBQUssTUFBTUMsUUFBUSxJQUFJdkIsSUFBSSxDQUFDMUUsT0FBTyxFQUFFO1FBQ25DLElBQUksSUFBQWtHLGtCQUFVLEVBQUN2RSxJQUFJLEVBQUVzRSxRQUFRLEVBQUV2QixJQUFJLENBQUMzRSxNQUFNLENBQUNvRyxRQUFRLENBQUMsRUFBRTtVQUNwREgsTUFBTSxHQUFHdEIsSUFBSSxDQUFDMUUsT0FBTyxDQUFDaUcsUUFBUSxDQUFDO1FBQ2pDO01BQ0Y7TUFFQSxJQUFJRCxNQUFNLElBQUksSUFBSSxFQUFFO1FBQ2xCQSxNQUFNLEdBQUcsSUFBSUksa0JBQVksQ0FDdkI7VUFDRUMsR0FBRyxFQUFFTixJQUFJLENBQUNNLEdBQUc7VUFDYkMsS0FBSyxFQUFFLElBQUk7VUFDWEMsY0FBYyxFQUFFO1FBQ2xCLENBQUMsRUFDRDdCLElBQUksQ0FBQzNFLE1BQ1AsQ0FBQztNQUNIO01BRUEsSUFBSXlHLFVBQWUsR0FBRyxJQUFJO01BQzFCLElBQUlSLE1BQU0sQ0FBQ2pHLE1BQU0sQ0FBQ3VHLEtBQUssRUFBRTtRQUN2QkUsVUFBVSxHQUFHOUIsSUFBSSxDQUFDdEUsWUFBWSxDQUFDb0UsVUFBVSxDQUFDN0MsSUFBSSxFQUFFNEMsUUFBUSxDQUFDO01BQzNEO01BRUEsSUFBSWtDLE9BQU8sR0FBRyxTQUFBQSxDQUFBLEVBQWtCO1FBQzlCO1FBQ0FBLE9BQU8sR0FBRyxTQUFBQSxDQUFBLEVBQVksQ0FBQyxDQUFDO1FBQ3hCLE1BQU1DLFFBQVEsR0FBR1YsTUFBTSxDQUFDVyxZQUFZLENBQUNaLElBQUksQ0FBQ00sR0FBRyxDQUFDO1FBQzlDSyxRQUFRLENBQUN6QixFQUFFLENBQUMsT0FBTyxFQUFFLFVBQVVuQyxHQUFHLEVBQVE7VUFDeEMsSUFBSTBELFVBQVUsRUFBRTtZQUNkQSxVQUFVLENBQUNuQixLQUFLLENBQUMsQ0FBQztVQUNwQjtVQUNBbUIsVUFBVSxHQUFHLElBQUk7VUFDakJsQixVQUFVLENBQUNFLElBQUksQ0FBQyxPQUFPLEVBQUUxQyxHQUFHLENBQUM7UUFDL0IsQ0FBQyxDQUFDO1FBQ0Y0RCxRQUFRLENBQUN6QixFQUFFLENBQUMsS0FBSyxFQUFFLFlBQWtCO1VBQ25DLElBQUl1QixVQUFVLEVBQUU7WUFDZEEsVUFBVSxDQUFDSSxJQUFJLENBQUMsQ0FBQztVQUNuQjtRQUNGLENBQUMsQ0FBQztRQUVGRixRQUFRLENBQUN6QixFQUFFLENBQUMsZ0JBQWdCLEVBQUUsVUFBVVksQ0FBQyxFQUFRO1VBQy9DUCxVQUFVLENBQUNFLElBQUksQ0FBQyxnQkFBZ0IsRUFBRUssQ0FBQyxDQUFDO1VBQ3BDLElBQUlXLFVBQVUsRUFBRTtZQUNkQSxVQUFVLENBQUNoQixJQUFJLENBQUMsZ0JBQWdCLEVBQUVLLENBQUMsQ0FBQztVQUN0QztRQUNGLENBQUMsQ0FBQztRQUNGYSxRQUFRLENBQUNaLElBQUksQ0FBQ1IsVUFBVSxDQUFDO1FBQ3pCLElBQUlrQixVQUFVLEVBQUU7VUFDZEUsUUFBUSxDQUFDWixJQUFJLENBQUNVLFVBQVUsQ0FBQztRQUMzQjtNQUNGLENBQUM7TUFFRCxJQUFJQSxVQUFVLEVBQUU7UUFDZEEsVUFBVSxDQUFDdkIsRUFBRSxDQUFDLE1BQU0sRUFBRSxZQUFrQjtVQUN0Q3dCLE9BQU8sQ0FBQyxDQUFDO1FBQ1gsQ0FBQyxDQUFDO1FBRUZELFVBQVUsQ0FBQ3ZCLEVBQUUsQ0FBQyxPQUFPLEVBQUUsVUFBVW5DLEdBQUcsRUFBUTtVQUMxQzRCLElBQUksQ0FBQ3hFLE1BQU0sQ0FBQ2lDLElBQUksQ0FDZDtZQUFFVyxHQUFHLEVBQUVBLEdBQUc7WUFBRStELFFBQVEsRUFBRWQ7VUFBSyxDQUFDLEVBQzVCLDZEQUNGLENBQUM7VUFDRCxJQUFJUyxVQUFVLEVBQUU7WUFDZEEsVUFBVSxDQUFDbkIsS0FBSyxDQUFDLENBQUM7VUFDcEI7VUFDQW1CLFVBQVUsR0FBRyxJQUFJO1VBQ2pCQyxPQUFPLENBQUMsQ0FBQztRQUNYLENBQUMsQ0FBQztNQUNKLENBQUMsTUFBTTtRQUNMQSxPQUFPLENBQUMsQ0FBQztNQUNYO0lBQ0Y7RUFDRjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFFU0ssVUFBVUEsQ0FBQ0MsT0FBTyxFQUFRO0lBQy9CLElBQUksQ0FBQzNHLFlBQVksQ0FBQ3NGLGtCQUFrQixDQUFDcUIsT0FBTyxDQUFDcEYsSUFBSSxFQUFFLENBQUNtQixHQUFHLEVBQUVrRSxJQUFJLEtBQVc7TUFDdEUsSUFBSWxFLEdBQUcsS0FBSyxDQUFDQSxHQUFHLENBQUNvQyxNQUFNLElBQUlwQyxHQUFHLENBQUNvQyxNQUFNLElBQUlDLHNCQUFXLENBQUM4QixjQUFjLENBQUMsRUFBRTtRQUNwRTtRQUNBLE9BQU9GLE9BQU8sQ0FBQ3hFLFFBQVEsQ0FBQ08sR0FBRyxDQUFDO01BQzlCO01BRUEsSUFBSSxDQUFDSCxvQkFBb0IsQ0FDdkJvRSxPQUFPLENBQUNwRixJQUFJLEVBQ1pxRixJQUFJLEVBQ0o7UUFBRUUsR0FBRyxFQUFFSCxPQUFPLENBQUNHLEdBQUc7UUFBRUMsV0FBVyxFQUFFSixPQUFPLENBQUNJO01BQVksQ0FBQyxFQUN0RCxTQUFTQyw0QkFBNEJBLENBQUN0RSxHQUFHLEVBQUV1RSxNQUFlLEVBQUVDLFlBQVksRUFBUTtRQUM5RSxJQUFJeEUsR0FBRyxFQUFFO1VBQ1AsT0FBT2lFLE9BQU8sQ0FBQ3hFLFFBQVEsQ0FBQ08sR0FBRyxDQUFDO1FBQzlCO1FBRUEsSUFBQXlFLHdCQUFpQixFQUFDLElBQUFDLDZCQUFlLEVBQUNULE9BQU8sQ0FBQ1UsY0FBYyxFQUFFSixNQUFNLENBQUMsQ0FBQzs7UUFFbEU7UUFDQUEsTUFBTSxDQUFDSyxZQUFZLEdBQUcsQ0FBQyxDQUFDO1FBQ3hCLElBQUlYLE9BQU8sQ0FBQ1ksV0FBVyxLQUFLLElBQUksRUFBRTtVQUNoQ1osT0FBTyxDQUFDeEUsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFBcUYsd0NBQTBCLEVBQUNQLE1BQU0sQ0FBQyxFQUFFQyxZQUFZLENBQUM7UUFDMUUsQ0FBQyxNQUFNO1VBQ0xQLE9BQU8sQ0FBQ3hFLFFBQVEsQ0FBQyxJQUFJLEVBQUU4RSxNQUFNLEVBQUVDLFlBQVksQ0FBQztRQUM5QztNQUNGLENBQ0YsQ0FBQztJQUNILENBQUMsQ0FBQztFQUNKOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNTTyxNQUFNQSxDQUFDQyxRQUFnQixFQUFFZixPQUFZLEVBQUU7SUFDNUMsTUFBTXJDLElBQUksR0FBRyxJQUFJO0lBQ2pCLE1BQU1xRCxZQUFpQixHQUFHLElBQUlDLGVBQU0sQ0FBQ0MsV0FBVyxDQUFDO01BQUVDLFVBQVUsRUFBRTtJQUFLLENBQUMsQ0FBQztJQUN0RUMsY0FBSyxDQUFDQyxVQUFVLENBQ2R2SixNQUFNLENBQUN3SixJQUFJLENBQUMsSUFBSSxDQUFDckksT0FBTyxDQUFDLEVBQ3pCLFVBQVVzSSxPQUFPLEVBQUVDLEVBQUUsRUFBUTtNQUFBLElBQUFDLFlBQUEsRUFBQUMsa0JBQUE7TUFDM0I7TUFDQSxJQUFJLEVBQUFELFlBQUEsR0FBQXpCLE9BQU8sQ0FBQ0csR0FBRyxjQUFBc0IsWUFBQSx3QkFBQUMsa0JBQUEsR0FBWEQsWUFBQSxDQUFhRSxLQUFLLGNBQUFELGtCQUFBLHVCQUFsQkEsa0JBQUEsQ0FBb0JFLEtBQUssTUFBS0MsU0FBUyxFQUFFO1FBQzNDLE9BQU9MLEVBQUUsQ0FBQyxDQUFDO01BQ2I7TUFDQXJJLGNBQU0sQ0FBQ3dCLElBQUksQ0FBQyxxQkFBcUI0RyxPQUFPLEVBQUUsQ0FBQztNQUMzQztNQUNBLE1BQU1PLFlBQVksR0FBR25FLElBQUksQ0FBQzFFLE9BQU8sQ0FBQ3NJLE9BQU8sQ0FBQyxDQUFDVCxNQUFNLENBQUNkLE9BQU8sQ0FBQztNQUMxRDtNQUNBOEIsWUFBWSxDQUFDL0MsSUFBSSxDQUFDaUMsWUFBWSxFQUFFO1FBQUVlLEdBQUcsRUFBRTtNQUFNLENBQUMsQ0FBQztNQUMvQ0QsWUFBWSxDQUFDNUQsRUFBRSxDQUFDLE9BQU8sRUFBRSxVQUFVbkMsR0FBRyxFQUFRO1FBQzVDNEIsSUFBSSxDQUFDeEUsTUFBTSxDQUFDbUUsS0FBSyxDQUFDO1VBQUV2QixHQUFHLEVBQUVBO1FBQUksQ0FBQyxFQUFFLDhCQUE4QixDQUFDO1FBQy9EeUYsRUFBRSxDQUFDLENBQUM7UUFDSjtRQUNBQSxFQUFFLEdBQUcsU0FBQUEsQ0FBQSxFQUFrQixDQUFDLENBQUM7TUFDM0IsQ0FBQyxDQUFDO01BQ0ZNLFlBQVksQ0FBQzVELEVBQUUsQ0FBQyxLQUFLLEVBQUUsWUFBa0I7UUFDdkNzRCxFQUFFLENBQUMsQ0FBQztRQUNKO1FBQ0FBLEVBQUUsR0FBRyxTQUFBQSxDQUFBLEVBQWtCLENBQUMsQ0FBQztNQUMzQixDQUFDLENBQUM7TUFFRlIsWUFBWSxDQUFDMUMsS0FBSyxHQUFHLFlBQWtCO1FBQ3JDLElBQUl3RCxZQUFZLENBQUN4RCxLQUFLLEVBQUU7VUFDdEJ3RCxZQUFZLENBQUN4RCxLQUFLLENBQUMsQ0FBQztRQUN0QjtRQUNBa0QsRUFBRSxDQUFDLENBQUM7UUFDSjtRQUNBQSxFQUFFLEdBQUcsU0FBQUEsQ0FBQSxFQUFrQixDQUFDLENBQUM7TUFDM0IsQ0FBQztJQUNILENBQUM7SUFDRDtJQUNBLFlBQWtCO01BQ2hCO01BQ0EsTUFBTVEsaUJBQWlCLEdBQUdyRSxJQUFJLENBQUN0RSxZQUFZLENBQUN5SCxNQUFNLENBQUNDLFFBQVEsRUFBRWYsT0FBTyxDQUFDO01BQ3JFZ0IsWUFBWSxDQUFDMUMsS0FBSyxHQUFHLFlBQWtCO1FBQ3JDMEQsaUJBQWlCLENBQUMxRCxLQUFLLENBQUMsQ0FBQztNQUMzQixDQUFDO01BQ0QwRCxpQkFBaUIsQ0FBQ2pELElBQUksQ0FBQ2lDLFlBQVksRUFBRTtRQUFFZSxHQUFHLEVBQUU7TUFBSyxDQUFDLENBQUM7TUFDbkRDLGlCQUFpQixDQUFDOUQsRUFBRSxDQUFDLE9BQU8sRUFBRSxVQUFVbkMsR0FBUSxFQUFRO1FBQ3RENEIsSUFBSSxDQUFDeEUsTUFBTSxDQUFDbUUsS0FBSyxDQUFDO1VBQUV2QixHQUFHLEVBQUVBO1FBQUksQ0FBQyxFQUFFLDhCQUE4QixDQUFDO1FBQy9EaUYsWUFBWSxDQUFDZSxHQUFHLENBQUMsQ0FBQztNQUNwQixDQUFDLENBQUM7SUFDSixDQUNGLENBQUM7SUFFRCxPQUFPZixZQUFZO0VBQ3JCOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0VBQ1NpQixnQkFBZ0JBLENBQUN6RyxRQUFrQixFQUFRO0lBQ2hELE1BQU1tQyxJQUFJLEdBQUcsSUFBSTtJQUNqQixJQUFJLENBQUN0RSxZQUFZLENBQUM2SSxhQUFhLENBQUNDLEdBQUcsQ0FBQyxDQUFDcEcsR0FBRyxFQUFFcUcsTUFBTSxLQUFXO01BQ3pELElBQUlyRyxHQUFHLEVBQUU7UUFDUFAsUUFBUSxDQUFDTyxHQUFHLENBQUM7TUFDZjtNQUVBLE1BQU1xRCxRQUFtQixHQUFHLEVBQUU7TUFDOUIsTUFBTVcsVUFBVSxHQUFHLFNBQUFBLENBQVVzQyxPQUFPLEVBQVE7UUFDMUMxRSxJQUFJLENBQUN0RSxZQUFZLENBQUNzRixrQkFBa0IsQ0FDbEN5RCxNQUFNLENBQUNDLE9BQU8sQ0FBQyxFQUNmLFVBQVV0RyxHQUFHLEVBQUV1RyxXQUFvQixFQUFRO1VBQ3pDLElBQUloSSxlQUFDLENBQUNDLEtBQUssQ0FBQ3dCLEdBQUcsQ0FBQyxFQUFFO1lBQ2hCLE1BQU13RyxNQUFNLEdBQUdELFdBQVcsQ0FBQ0Usb0JBQVMsQ0FBQyxDQUFDRCxNQUFNO1lBQzVDLElBQUlBLE1BQU0sSUFBSUQsV0FBVyxDQUFDRyxRQUFRLENBQUNGLE1BQU0sQ0FBQyxFQUFFO2NBQzFDLE1BQU01RixPQUFnQixHQUFHMkYsV0FBVyxDQUFDRyxRQUFRLENBQUNGLE1BQU0sQ0FBQztjQUNyRCxNQUFNRyxRQUFRLEdBQUdKLFdBQVcsQ0FBQ0ssSUFBbUI7Y0FDaEQsTUFBTUEsSUFBSSxHQUFHRCxRQUFRLENBQUNILE1BQU0sQ0FBQztjQUM3QjtjQUNBNUYsT0FBTyxDQUFDZ0csSUFBSSxHQUFHQSxJQUFJOztjQUVuQjtjQUNBO2NBQ0FoRyxPQUFPLENBQUNpRyxLQUFLLEdBQUdOLFdBQVcsQ0FBQ00sS0FBSztjQUVqQ3hELFFBQVEsQ0FBQ3lELElBQUksQ0FBQ2xHLE9BQU8sQ0FBQztZQUN4QixDQUFDLE1BQU07Y0FDTGdCLElBQUksQ0FBQ3hFLE1BQU0sQ0FBQ2lDLElBQUksQ0FDZDtnQkFBRTBILE9BQU8sRUFBRVYsTUFBTSxDQUFDQyxPQUFPO2NBQUUsQ0FBQyxFQUM1QixrREFDRixDQUFDO1lBQ0g7VUFDRjtVQUVBLElBQUlBLE9BQU8sSUFBSUQsTUFBTSxDQUFDaEksTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNoQ29CLFFBQVEsQ0FBQyxJQUFJLEVBQUU0RCxRQUFRLENBQUM7VUFDMUIsQ0FBQyxNQUFNO1lBQ0xXLFVBQVUsQ0FBQ3NDLE9BQU8sR0FBRyxDQUFDLENBQUM7VUFDekI7UUFDRixDQUNGLENBQUM7TUFDSCxDQUFDO01BRUQsSUFBSUQsTUFBTSxDQUFDaEksTUFBTSxFQUFFO1FBQ2pCMkYsVUFBVSxDQUFDLENBQUMsQ0FBQztNQUNmLENBQUMsTUFBTTtRQUNMdkUsUUFBUSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUM7TUFDcEI7SUFDRixDQUFDLENBQUM7RUFDSjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBQ1NJLG9CQUFvQkEsQ0FDekJoQixJQUFZLEVBQ1ptSSxXQUFxQixFQUNyQi9DLE9BQXFCLEVBQ3JCeEUsUUFBa0IsRUFDWjtJQUNOLElBQUl3SCxLQUFLLEdBQUcsSUFBSTtJQUNoQixNQUFNckYsSUFBSSxHQUFHLElBQUk7SUFDakIsTUFBTXNGLE9BQXVCLEdBQUcsRUFBRTtJQUNsQyxNQUFNQyxvQkFBb0IsR0FBRzVJLGVBQUMsQ0FBQ0MsS0FBSyxDQUFDeUYsT0FBTyxDQUFDSSxXQUFXLENBQUMsSUFBSUosT0FBTyxDQUFDSSxXQUFXO0lBRWhGLElBQUksQ0FBQzJDLFdBQVcsRUFBRTtNQUNoQkMsS0FBSyxHQUFHLEtBQUs7TUFDYkQsV0FBVyxHQUFHLElBQUFJLHFDQUF1QixFQUFDdkksSUFBSSxDQUFDO0lBQzdDO0lBRUEsS0FBSyxNQUFNcUUsTUFBTSxJQUFJLElBQUksQ0FBQ2hHLE9BQU8sRUFBRTtNQUNqQyxJQUFJLElBQUFrRyxrQkFBVSxFQUFDdkUsSUFBSSxFQUFFcUUsTUFBTSxFQUFFLElBQUksQ0FBQ2pHLE1BQU0sQ0FBQ29HLFFBQVEsQ0FBQyxJQUFJOEQsb0JBQW9CLEVBQUU7UUFDMUVELE9BQU8sQ0FBQ0osSUFBSSxDQUFDLElBQUksQ0FBQzVKLE9BQU8sQ0FBQ2dHLE1BQU0sQ0FBQyxDQUFDO01BQ3BDO0lBQ0Y7SUFFQW1DLGNBQUssQ0FBQ2dDLEdBQUcsQ0FDUEgsT0FBTyxFQUNQLENBQUNJLE1BQW9CLEVBQUU3QixFQUFFLEtBQVc7TUFDbEMsTUFBTThCLFFBQVEsR0FBR3hMLE1BQU0sQ0FBQ3lMLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRXZELE9BQU8sQ0FBQztNQUMzQyxNQUFNd0QsVUFBVSxHQUFHVCxXQUFXLENBQUNVLFFBQVEsQ0FBQ0osTUFBTSxDQUFDSyxNQUFNLENBQUM7TUFFdEQsSUFBSSxJQUFBQyxlQUFRLEVBQUNILFVBQVUsQ0FBQyxFQUFFO1FBQ3hCLE1BQU1JLE9BQU8sR0FBR0osVUFBVSxDQUFDSSxPQUFPO1FBRWxDLElBQUlBLE9BQU8sSUFBSUMsSUFBSSxDQUFDQyxHQUFHLENBQUMsQ0FBQyxHQUFHRixPQUFPLEdBQUdQLE1BQU0sQ0FBQ1UsTUFBTSxFQUFFO1VBQ25ELE9BQU92QyxFQUFFLENBQUMsQ0FBQztRQUNiO1FBRUE4QixRQUFRLENBQUNVLElBQUksR0FBR1IsVUFBVSxDQUFDUSxJQUFJO01BQ2pDO01BRUFYLE1BQU0sQ0FBQ1ksaUJBQWlCLENBQUNySixJQUFJLEVBQUUwSSxRQUFRLEVBQUUsQ0FBQ3ZILEdBQUcsRUFBRW1JLGNBQWMsRUFBRUMsSUFBSSxLQUFXO1FBQzVFLElBQUlwSSxHQUFHLElBQUlBLEdBQUcsQ0FBQ3FJLFlBQVksS0FBSyxHQUFHLEVBQUU7VUFDbkNaLFVBQVUsQ0FBQ0ksT0FBTyxHQUFHQyxJQUFJLENBQUNDLEdBQUcsQ0FBQyxDQUFDO1FBQ2pDO1FBRUEsSUFBSS9ILEdBQUcsSUFBSSxDQUFDbUksY0FBYyxFQUFFO1VBQzFCLE9BQU8xQyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUN6RixHQUFHLElBQUlzSSxnQkFBUyxDQUFDQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBQ2pFO1FBRUEsSUFBSTtVQUNGSixjQUFjLEdBQUdLLHFCQUFlLENBQUNDLGlCQUFpQixDQUFDTixjQUFjLEVBQUV0SixJQUFJLENBQUM7UUFDMUUsQ0FBQyxDQUFDLE9BQU9tQixHQUFHLEVBQUU7VUFDWjRCLElBQUksQ0FBQ3hFLE1BQU0sQ0FBQ21FLEtBQUssQ0FDZjtZQUNFbUgsR0FBRyxFQUFFLEtBQUs7WUFDVjFJLEdBQUcsRUFBRUE7VUFDUCxDQUFDLEVBQ0QsNkRBQ0YsQ0FBQztVQUNELE9BQU95RixFQUFFLENBQUMsSUFBSSxFQUFFLENBQUN6RixHQUFHLENBQUMsQ0FBQztRQUN4QjtRQUVBZ0gsV0FBVyxDQUFDVSxRQUFRLENBQUNKLE1BQU0sQ0FBQ0ssTUFBTSxDQUFDLEdBQUc7VUFDcENNLElBQUksRUFBRUcsSUFBSTtVQUNWUCxPQUFPLEVBQUVDLElBQUksQ0FBQ0MsR0FBRyxDQUFDO1FBQ3BCLENBQUM7UUFFRGYsV0FBVyxHQUFHLElBQUEyQixzQ0FBd0IsRUFBQzNCLFdBQVcsRUFBRW1CLGNBQWMsQ0FBQztRQUVuRSxJQUFBUyxzQ0FBMEIsRUFBQ1QsY0FBYyxDQUFDekIsUUFBUSxFQUFFWSxNQUFNLENBQUM7UUFFM0QsSUFBSTtVQUNGLElBQUF1Qiw0QkFBYSxFQUFDN0IsV0FBVyxFQUFFbUIsY0FBYyxDQUFDO1FBQzVDLENBQUMsQ0FBQyxPQUFPbkksR0FBRyxFQUFFO1VBQ1o0QixJQUFJLENBQUN4RSxNQUFNLENBQUNtRSxLQUFLLENBQ2Y7WUFDRW1ILEdBQUcsRUFBRSxLQUFLO1lBQ1YxSSxHQUFHLEVBQUVBO1VBQ1AsQ0FBQyxFQUNELDBEQUNGLENBQUM7VUFDRCxPQUFPeUYsRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDekYsR0FBRyxDQUFDLENBQUM7UUFDeEI7O1FBRUE7UUFDQTtRQUNBaUgsS0FBSyxHQUFHLElBQUk7UUFDWnhCLEVBQUUsQ0FBQyxDQUFDO01BQ04sQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUNEO0lBQ0EsQ0FBQ3pGLEdBQVUsRUFBRThJLGFBQWtCLEtBQStDO01BQzVFLElBQUFySyxlQUFNLEVBQUMsQ0FBQ3VCLEdBQUcsSUFBSStJLEtBQUssQ0FBQ0MsT0FBTyxDQUFDRixhQUFhLENBQUMsQ0FBQzs7TUFFNUM7TUFDQTtNQUNBLElBQUksQ0FBQzdCLEtBQUssRUFBRTtRQUNWLElBQUlnQyxrQkFBa0I7UUFDdEIsS0FBSyxJQUFJNU0sQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHeU0sYUFBYSxDQUFDekssTUFBTSxFQUFFaEMsQ0FBQyxFQUFFLEVBQUU7VUFDN0MsSUFBSXlNLGFBQWEsQ0FBQ3pNLENBQUMsQ0FBQyxFQUFFO1lBQ3BCLEtBQUssSUFBSTZNLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR0osYUFBYSxDQUFDek0sQ0FBQyxDQUFDLENBQUNnQyxNQUFNLEVBQUU2SyxDQUFDLEVBQUUsRUFBRTtjQUNoRCxJQUFJSixhQUFhLENBQUN6TSxDQUFDLENBQUMsQ0FBQzZNLENBQUMsQ0FBQyxFQUFFO2dCQUN2QixNQUFNQyxJQUFJLEdBQUdMLGFBQWEsQ0FBQ3pNLENBQUMsQ0FBQyxDQUFDNk0sQ0FBQyxDQUFDLENBQUNDLElBQUk7Z0JBQ3JDLElBQUlBLElBQUksS0FBSyxXQUFXLElBQUlBLElBQUksS0FBSyxpQkFBaUIsSUFBSUEsSUFBSSxLQUFLLFlBQVksRUFBRTtrQkFDL0VGLGtCQUFrQixHQUFHLElBQUk7a0JBQ3pCO2dCQUNGO2NBQ0Y7WUFDRjtVQUNGO1FBQ0Y7UUFFQSxJQUFJQSxrQkFBa0IsRUFBRTtVQUN0QixPQUFPeEosUUFBUSxDQUFDNkksZ0JBQVMsQ0FBQ2MscUJBQXFCLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRU4sYUFBYSxDQUFDO1FBQ3pFO1FBQ0EsT0FBT3JKLFFBQVEsQ0FBQzZJLGdCQUFTLENBQUNlLFdBQVcsQ0FBQ0Msb0JBQVMsQ0FBQ0MsVUFBVSxDQUFDLEVBQUUsSUFBSSxFQUFFVCxhQUFhLENBQUM7TUFDbkY7TUFFQSxJQUFJNUIsT0FBTyxDQUFDN0ksTUFBTSxLQUFLLENBQUMsRUFBRTtRQUN4QixPQUFPb0IsUUFBUSxDQUFDLElBQUksRUFBRXVILFdBQVcsQ0FBQztNQUNwQztNQUVBcEYsSUFBSSxDQUFDdEUsWUFBWSxDQUFDa00sY0FBYyxDQUM5QjNLLElBQUksRUFDSm1JLFdBQVcsRUFDWCxPQUFPaEgsR0FBRyxFQUFFeUosZ0JBQXlCLEtBQW1CO1FBQ3RELElBQUl6SixHQUFHLEVBQUU7VUFDUCxPQUFPUCxRQUFRLENBQUNPLEdBQUcsQ0FBQztRQUN0QjtRQUNBO1FBQ0E7UUFDQSxNQUFNMEosWUFBcUIsR0FBRyxFQUFFO1FBQ2hDO1FBQ0EsS0FBSyxNQUFNckosTUFBTSxJQUFJdUIsSUFBSSxDQUFDdkUsT0FBTyxFQUFFO1VBQ2pDLElBQUk7WUFDRjtZQUNBO1lBQ0FvTSxnQkFBZ0IsR0FBRyxNQUFNcEosTUFBTSxDQUFDckMsZUFBZSxDQUFDeUwsZ0JBQWdCLENBQUM7VUFDbkUsQ0FBQyxDQUFDLE9BQU96SixHQUFRLEVBQUU7WUFDakIwSixZQUFZLENBQUM1QyxJQUFJLENBQUM5RyxHQUFHLENBQUM7VUFDeEI7UUFDRjtRQUNBUCxRQUFRLENBQUMsSUFBSSxFQUFFZ0ssZ0JBQWdCLEVBQUVsTCxlQUFDLENBQUNvTCxNQUFNLENBQUNiLGFBQWEsRUFBRVksWUFBWSxDQUFDLENBQUM7TUFDekUsQ0FDRixDQUFDO0lBQ0gsQ0FDRixDQUFDO0VBQ0g7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ1NFLDJCQUEyQkEsQ0FBQ2xELFFBQWtCLEVBQUVZLE1BQW9CLEVBQVE7SUFDakYsS0FBSyxNQUFNakwsQ0FBQyxJQUFJcUssUUFBUSxFQUFFO01BQ3hCLElBQUkzSyxNQUFNLENBQUM4TixTQUFTLENBQUNDLGNBQWMsQ0FBQ3JOLElBQUksQ0FBQ2lLLFFBQVEsRUFBRXJLLENBQUMsQ0FBQyxFQUFFO1FBQ3JELE1BQU11RSxPQUFPLEdBQUc4RixRQUFRLENBQUNySyxDQUFDLENBQUM7O1FBRTNCO1FBQ0F1RSxPQUFPLENBQUNyRSxNQUFNLENBQUN3TixHQUFHLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxHQUFHekMsTUFBTSxDQUFDSyxNQUFNO01BQzNEO0lBQ0Y7RUFDRjtBQUNGO0FBQUMsSUFBQXFDLFFBQUEsR0FBQUMsT0FBQSxDQUFBdk8sT0FBQSxHQUVjcUIsT0FBTyIsImlnbm9yZUxpc3QiOltdfQ==