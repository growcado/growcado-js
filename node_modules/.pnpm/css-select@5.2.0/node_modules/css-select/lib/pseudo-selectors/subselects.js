"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.subselects = exports.PLACEHOLDER_ELEMENT = void 0;
var boolbase = require("boolbase");
var cache_js_1 = require("../helpers/cache.js");
var selectors_js_1 = require("../helpers/selectors.js");
var querying_js_1 = require("../helpers/querying.js");
/** Used as a placeholder for :has. Will be replaced with the actual element. */
exports.PLACEHOLDER_ELEMENT = {};
/**
 * Check if the selector has any properties that rely on the current element.
 * If not, we can cache the result of the selector.
 *
 * We can't cache selectors that start with a traversal (e.g. `>`, `+`, `~`),
 * or include a `:scope`.
 *
 * @param selector - The selector to check.
 * @returns Whether the selector has any properties that rely on the current element.
 */
function hasDependsOnCurrentElement(selector) {
    return selector.some(function (sel) {
        return sel.length > 0 &&
            ((0, selectors_js_1.isTraversal)(sel[0]) || sel.some(selectors_js_1.includesScopePseudo));
    });
}
function copyOptions(options) {
    // Not copied: context, rootFunc
    return {
        xmlMode: !!options.xmlMode,
        lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
        lowerCaseTags: !!options.lowerCaseTags,
        quirksMode: !!options.quirksMode,
        cacheResults: !!options.cacheResults,
        pseudos: options.pseudos,
        adapter: options.adapter,
        equals: options.equals,
    };
}
var is = function (next, token, options, context, compileToken) {
    var func = compileToken(token, copyOptions(options), context);
    return func === boolbase.trueFunc
        ? next
        : func === boolbase.falseFunc
            ? boolbase.falseFunc
            : function (elem) { return func(elem) && next(elem); };
};
/*
 * :not, :has, :is, :matches and :where have to compile selectors
 * doing this in src/pseudos.ts would lead to circular dependencies,
 * so we add them here
 */
exports.subselects = {
    is: is,
    /**
     * `:matches` and `:where` are aliases for `:is`.
     */
    matches: is,
    where: is,
    not: function (next, token, options, context, compileToken) {
        var func = compileToken(token, copyOptions(options), context);
        return func === boolbase.falseFunc
            ? next
            : func === boolbase.trueFunc
                ? boolbase.falseFunc
                : function (elem) { return !func(elem) && next(elem); };
    },
    has: function (next, subselect, options, _context, compileToken) {
        var adapter = options.adapter;
        var opts = copyOptions(options);
        opts.relativeSelector = true;
        var context = subselect.some(function (s) { return s.some(selectors_js_1.isTraversal); })
            ? // Used as a placeholder. Will be replaced with the actual element.
                [exports.PLACEHOLDER_ELEMENT]
            : undefined;
        var skipCache = hasDependsOnCurrentElement(subselect);
        var compiled = compileToken(subselect, opts, context);
        if (compiled === boolbase.falseFunc)
            return boolbase.falseFunc;
        // If `compiled` is `trueFunc`, we can skip this.
        if (context && compiled !== boolbase.trueFunc) {
            return skipCache
                ? function (elem) {
                    if (!next(elem))
                        return false;
                    context[0] = elem;
                    var childs = adapter.getChildren(elem);
                    return ((0, querying_js_1.findOne)(compiled, compiled.shouldTestNextSiblings
                        ? __spreadArray(__spreadArray([], childs, true), (0, querying_js_1.getNextSiblings)(elem, adapter), true) : childs, options) !== null);
                }
                : (0, cache_js_1.cacheParentResults)(next, options, function (elem) {
                    context[0] = elem;
                    return ((0, querying_js_1.findOne)(compiled, adapter.getChildren(elem), options) !== null);
                });
        }
        var hasOne = function (elem) {
            return (0, querying_js_1.findOne)(compiled, adapter.getChildren(elem), options) !== null;
        };
        return skipCache
            ? function (elem) { return next(elem) && hasOne(elem); }
            : (0, cache_js_1.cacheParentResults)(next, options, hasOne);
    },
};
//# sourceMappingURL=subselects.js.map